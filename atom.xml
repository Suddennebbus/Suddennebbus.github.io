<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>DengSha</title>
  
  <subtitle>Data Hero</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-05-25T12:10:36.000Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Deng Sha</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>统计学习方法 | 朴素贝叶斯法</title>
    <link href="http://yoursite.com/2018/05/25/%E7%BB%9F%E8%AE%A1%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95-%E6%9C%B4%E7%B4%A0%E8%B4%9D%E5%8F%B6%E6%96%AF%E6%B3%95/"/>
    <id>http://yoursite.com/2018/05/25/统计学习方法-朴素贝叶斯法/</id>
    <published>2018-05-25T07:14:12.000Z</published>
    <updated>2018-05-25T12:10:36.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://upload-images.jianshu.io/upload_images/4263204-e2c41bac954de01f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><a id="more"></a><h4 id="01-分类方法"><a href="#01-分类方法" class="headerlink" title="01 分类方法"></a>01 分类方法</h4><p>之前我们学习了一种分类方法——<a href="https://www.jianshu.com/p/73a0a3b229e6" target="_blank" rel="noopener">K近邻法(KNN)</a>，今天我们再学习一种更常用的分类方法</p><blockquote><p>朴素贝叶斯法</p></blockquote><p>这里，我们先区分一下“分类”和“聚类”</p><blockquote><ul><li><p>分类的目的是学会一个分类函数或分类模型(也常常称作分类器 )，该模型能把新输入的数据映射到给定类别中的某一个类中。</p></li><li><p>聚类(clustering)是指根据“物以类聚”原理，将本身没有类别的样本聚集成不同的组(簇)，并且对每一个这样的簇进行描述的过程。它的目的是使得属于同一个簇的样本之间应该彼此相似，而不同簇的样本应该足够不相似。</p></li></ul></blockquote><p>我们在上一篇文章中讲到的K-Means就属于聚类算法，KNN、朴素贝叶斯则属于分类方法。</p><p>下面详细讲解朴素贝叶斯方法。</p><h4 id="02-相关概念"><a href="#02-相关概念" class="headerlink" title="02 相关概念"></a>02 相关概念</h4><p>学习朴素贝叶斯之前，先理清下面三个概念，要不然你的脑袋会晕掉的。</p><ol><li><p>先验概率<br>事件发生前的预判概率。可以是基于历史数据的统计，可以由背景常识得出，也可以是人的主观观点给出。一般都是单独事件概率，如P(X),P(Y)。</p></li><li><p>条件概率<br>事件发生后求的反向条件概率；或者说，基于先验概率求得的反向条件概率。表达形式与条件概率相同。如P(Y|X)</p></li><li><p>后验概率<br>一个事件发生后另一个事件发生的概率。一般的形式为P(X|Y)，表示Y发生的条件下X发生的概率。</p></li></ol><h4 id="03-朴素贝叶斯"><a href="#03-朴素贝叶斯" class="headerlink" title="03 朴素贝叶斯"></a>03 朴素贝叶斯</h4><p><strong>基本假设</strong><br>朴素贝叶斯，英文叫Naive Bayes。</p><p><strong>Naive？</strong></p><p>那是有原因的，朴素贝叶斯对输入变量做了一个很强的假设——条件独立</p><blockquote><p><strong>条件独立</strong></p><p>输入变量之间是相互独立的，没有概率依存关系。（若相互依存，那叫贝叶斯网络）</p><p>即，用于分类的特征(xj)在类(y=ck)确定的条件下，都是相互独立的，即<br>P(X=x|Y=ck)=P(X1=x2,X2=x2…Xn=xn|Y=ck)<br>=P(X1=x1|Y=ck)P(X2=x2|Y=ck)…P(Xn=xn|Y=ck)</p></blockquote><p>就是这么个意思：<img src="https://upload-images.jianshu.io/upload_images/4263204-9a2e2d1a2501d3f8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p><strong>贝叶斯公式</strong></p><p>基本原理：P(X,Y)=P(Y|X)P(X)=P(X|Y)P(Y) =&gt; P(Y|X)=P(X|Y)P(Y)/P(X)</p><p>于是对于后验概率P(Y|X)，有：<img src="https://upload-images.jianshu.io/upload_images/4263204-87e90cb65e0b2dc4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p><strong>朴素贝叶斯分类器</strong></p><p>根据贝叶斯公式，朴素贝叶斯分类器就产生了：<br>y=f(x)=argmax(P(Y|X))</p><p>一波公式变换和等价之后，得到了朴素贝叶斯分类器：<img src="https://upload-images.jianshu.io/upload_images/4263204-7925a9c09ec7460d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p><strong>这个分类器要做的就是，对于新输入x，计算所有可能的Y对应的后验概率P(Y|X)，认为后验概率最大的那个Y就是这个新输入x的类。</strong></p><h4 id="04-朴素贝叶斯的参数估计方法"><a href="#04-朴素贝叶斯的参数估计方法" class="headerlink" title="04 朴素贝叶斯的参数估计方法"></a>04 朴素贝叶斯的参数估计方法</h4><p><strong>参数估计目的</strong></p><p>根据上一节，朴素贝叶斯分类器其实就是先验概率P(Y)和条件概率P(X|Y)的乘积，要使用朴素贝叶斯分类器，就要估计先验概率P(Y=ck)和条件概率P(Xj=ajl|Y=ck)，这就是参数估计。</p><p>常使用极大似然估计和贝叶斯估计去求这两个概率。</p><p><strong>极大似然估计</strong></p><ul><li><p>先验概率<img src="https://upload-images.jianshu.io/upload_images/4263204-c7ba7d5ddcdb94eb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p></li><li><p>条件概率<img src="https://upload-images.jianshu.io/upload_images/4263204-b9cc5c142f7d5256.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p></li></ul><p><strong>贝叶斯估计</strong></p><ul><li><p>先验概率<img src="https://upload-images.jianshu.io/upload_images/4263204-e2f134b8527393a9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p></li><li><p>条件概率<img src="https://upload-images.jianshu.io/upload_images/4263204-beae24f45f080f8c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p></li></ul><p>上式的朗母达=1时，叫做——拉普拉斯平滑(Laplace smoothing)</p><p><strong>相比于极大似然估计，贝叶斯估计可以处理有概率为0的情况，加入了Sj、K等参数，其中Sj是X的第i个参数的第j个特征可能的数值个数，K是Y可能的类别个数。</strong></p><h4 id="05-朴素贝叶斯算法过程"><a href="#05-朴素贝叶斯算法过程" class="headerlink" title="05 朴素贝叶斯算法过程"></a>05 朴素贝叶斯算法过程</h4><p>在看下面这个算法过程的时候，建议你脑子里一直想着一个实例：垃圾邮件分类。</p><p><img src="https://upload-images.jianshu.io/upload_images/4263204-a29f06461a90977d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>算法过程看完可能还是云里雾里，我们举个例子说明吧。</p><p><img src="https://upload-images.jianshu.io/upload_images/4263204-9c63df018116e57f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p><img src="https://upload-images.jianshu.io/upload_images/4263204-af315cf18beb7398.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><h4 id="06-总结"><a href="#06-总结" class="headerlink" title="06 总结"></a>06 总结</h4><p>今天我们学习了另一种分类方法：朴素贝叶斯法，它实现简单，学习和预测的效率较高，是一种很常用的分类方法，比如垃圾邮件分类、商品映射到行业体系等。</p><p>注意区分分类和聚类方法。</p><p>下期我们将学习另一种分类方法——决策树，敬请期待~~</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/4263204-e2c41bac954de01f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="统计学习方法" scheme="http://yoursite.com/categories/%E7%BB%9F%E8%AE%A1%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95/"/>
    
    
      <category term="统计学习方法" scheme="http://yoursite.com/tags/%E7%BB%9F%E8%AE%A1%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>统计学习方法 | k近邻法</title>
    <link href="http://yoursite.com/2018/05/25/%E7%BB%9F%E8%AE%A1%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95-k%E8%BF%91%E9%82%BB%E6%B3%95/"/>
    <id>http://yoursite.com/2018/05/25/统计学习方法-k近邻法/</id>
    <published>2018-05-25T07:13:12.000Z</published>
    <updated>2018-05-25T12:10:22.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://upload-images.jianshu.io/upload_images/4263204-d64e406b8eb190ad.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><a id="more"></a><h4 id="01-分类需求"><a href="#01-分类需求" class="headerlink" title="01 分类需求"></a>01 分类需求</h4><p><strong>K近邻法（KNN）是一种基本的分类与回归方法</strong></p><blockquote><p>分类这种需求，渗透到我们生活的方方面面：</p><ul><li>根据学生德智体美成绩，将学生分为几类</li><li>根据一个县城的GDP、人口密度等数据，将全国的县城分为多个类别</li><li>根据客户的信用、收入、生活习惯将客户分为多个类别</li><li>……</li></ul></blockquote><p>分类算法可以帮助我们完成这些繁琐的操作，并根据我们的要求不断修正分类结果。</p><p>分类算法其实蛮多的，这里顺着书本顺序，详细讲解KNN算法，再与K-Means、K-Means++算法进行简单对比。</p><h4 id="02-KNN算法"><a href="#02-KNN算法" class="headerlink" title="02 KNN算法"></a>02 KNN算法</h4><p>k近邻法是这样一个过程：</p><blockquote><p>给定一个训练数据集，对新的输入实例，在训练数据集中找到与该实例最邻近的k个实例，这k个实例的多数属于某个类（多数表决argmax），就把该输入实例分为这个类。</p></blockquote><p>过程其实很好理解，描述成可量化的算法，就是这样的：</p><p><img src="https://upload-images.jianshu.io/upload_images/4263204-17794c4d8dcc7fad.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>KNN是一种懒惰算法，平时不好好学习，考试（对测试样本分类）时才临阵磨枪（临时去找k个近邻）。</p><p>懒惰的后果：构造模型很简单，但在对测试样本分类的开销大，因为要扫描全部训练样本并计算距离。</p><p>理解算法后，我们来看看k近邻法的优缺点：</p><blockquote><p>优点：易于实现，无需估计参数，无需训练，支持增量学习，能对超多边形的复杂决策空间建模</p><p>缺点：计算量较大，分析速度慢（因为要扫描全部训练样本并计算距离）</p></blockquote><h4 id="03-KNN-vs-K-Means-vs-K-Means"><a href="#03-KNN-vs-K-Means-vs-K-Means" class="headerlink" title="03 KNN vs K-Means vs K-Means++"></a>03 KNN vs K-Means vs K-Means++</h4><p>开头我们说到，分类算法很多，KNN只是其中一种，下面我们将KNN算法与K-Means、K-Means++进行对比，便于我们更好地理解算法。</p><p><strong>KNN</strong><br>给定一个训练数据集，对新的输入实例，在训练数据集中找到与该实例最邻近的k个实例，这k个实例的多数属于某个类（多数表决argmax），就把该输入实例分为这个类。</p><p><strong>K-Means</strong><br>不断地聚类<-->划分过程<br>（1）对于一组数据集，任意选取k个点作为质心，将数据集中的点归为离其最近的质心一类，此时数据集被划分为k个类；<br>（2）对这k个类，重新寻找各类的质心；<br>（3）根据新产生的质心，按照（1）继续聚类，然后再根据聚类重新计算各类质心，直到质心不再改变，分类完成。</--></p><p>下面的图可以很直观地展示整个分类过程</p><p><img src="https://upload-images.jianshu.io/upload_images/4263204-7ef1a37964c0c717.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="需要注意的是，此图示展示的K-Means聚类过程，第一步选取的红蓝两点质心是错的，质心应该是训练数据集中的点，后面的步骤没有问题"></p><p><strong>K-Means++</strong><br>与K-Means算法相同，除了第一步初始质心的选择：选择初始质心时并不是随机选择，而是选择尽量相互分离的质心，即，下一个质心点总是离上一个质心点较远的点。</p><h4 id="04-KNN三要素"><a href="#04-KNN三要素" class="headerlink" title="04 KNN三要素"></a>04 KNN三要素</h4><p><strong>距离度量、k值、分类决策规则</strong>，是k近邻法地三要素，下面分别介绍。</p><p><img src="https://upload-images.jianshu.io/upload_images/4263204-abc722692691d222.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p><strong>距离度量</strong><br>衡量特征空间中两个实例点的距离，度量方法一边用Lp距离，p取不同值时，分别有不同地名称，常用欧氏距离作为距离度量。</p><ul><li><p><strong>Lp距离</strong><img src="https://upload-images.jianshu.io/upload_images/4263204-70b69478455915fe.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p></li><li><p><strong>欧氏距离(p=2)</strong> <img src="https://upload-images.jianshu.io/upload_images/4263204-834e4bdee4e8181d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p></li><li><p><strong>曼哈顿距离(p=1)</strong> <img src="https://upload-images.jianshu.io/upload_images/4263204-a59b0fa7440a63e8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p></li><li><p><strong>p无穷</strong> <img src="https://upload-images.jianshu.io/upload_images/4263204-5cb1c5c586b6c500.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p></li></ul><p>不同的距离度量，得到的实例点之间的距离是不同的，下面的图给出了二维空间中，p取不同值时，与原点的Lp距离为1的点的集合图形，可以看到，欧氏距离对应的是圆。</p><p><img src="https://upload-images.jianshu.io/upload_images/4263204-a11e60f7fcacb5bf.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p><strong>k值</strong></p><blockquote><p>k值得选择，反映了对近似误差与估计误差之间的权衡。</p></blockquote><ul><li><p><strong>近似误差</strong><br>类比于训练误差，关注训练集。近似误差越小，说明模型对训练集的预测越好，但近似误差过小容易出现过拟合，降低模型对于测试集的预测准确性。</p></li><li><p><strong>估计误差</strong><br>类比于测试误差，关注测试集。估计误差越小，说明模型对未知数据预测越好，模型越接近真实模型，过小的近似误差会导致模型过拟合，使得模型对于未知数据的预测变差（估计误差变大）</p></li><li><p><strong>k值过小</strong></p><ul><li>近似误差会减小，估计误差会增大</li><li>易产生过拟合</li><li>噪声敏感：如果邻近的实例点恰好是噪声，预测就会出错。</li></ul></li><li><p>k值过大</p><ul><li>可以减少估计误差，但近似误差会增大</li><li>极端情况，k=样本点数N，无论输入实例如何，都将被简单归为训练集中最多的类，忽略了大量有用信息</li></ul></li></ul><p><strong>分类决策规则</strong></p><p>k近邻法中得分类决策规则，常用多数表决法，当然，为了弱化k值的影响，还可以采用加权表决法。</p><ul><li><p><strong>多数表决</strong></p><ul><li>由输入实例的k个邻近的训练实例中的多数类决定输入实例的类</li><li>不考虑距离加权影响，每个投票权重都为1</li></ul></li><li><p><strong>加权表决</strong></p><ul><li>由输入实例的k个邻近的训练实例中的多数类加权决定输入实例的类<br> -即根据距离的远近，对近邻的投票进行加权，距离越近则权重越大（权重为距离平方的倒数）</li></ul></li></ul><p>为什么要使用多数表决法呢，这里给出多数表决法的直观解释，这个解释我给满分！</p><p><img src="https://upload-images.jianshu.io/upload_images/4263204-73a62534ee254c35.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><h4 id="05-kd树（二叉树）"><a href="#05-kd树（二叉树）" class="headerlink" title="05 kd树（二叉树）"></a>05 kd树（二叉树）</h4><p>了解了k近邻法后，你应该会产生这样的疑惑：</p><blockquote><p>如何对训练数据进行快速k近邻搜索？</p></blockquote><p>难道用线性扫描么？</p><blockquote><p>要计算输入实例与训练集每一个实例的距离，当训练集很大时，计算非常耗时，<strong>不可取</strong></p></blockquote><p>面对大数据量的训练集，人们想出了一个好办法提高搜索效率：</p><blockquote><p>使用特殊的数据结构存储训练数据，以减少计算距离的次数，这就是——kd树</p></blockquote><p>下面结合示例，讲解如何构造kd树以及如何搜索kd树</p><ul><li><p><strong>构造kd树</strong><br><img src="https://upload-images.jianshu.io/upload_images/4263204-b46f49f7001afb2b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p></li><li><p><strong>示例-构造kd树</strong><br><img src="https://upload-images.jianshu.io/upload_images/4263204-586f6f61f61169fe.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p></li></ul><p>一波操作之后，得到的kd树直观理解长成这样：</p><p><img src="https://upload-images.jianshu.io/upload_images/4263204-46ce632efb0248c9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><ul><li><p><strong>搜索kd树</strong><br><img src="https://upload-images.jianshu.io/upload_images/4263204-2ec2b2491a1d75c1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p></li><li><p><strong>示例-搜索kd树</strong><br><img src="https://upload-images.jianshu.io/upload_images/4263204-869923f8fec236b8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p></li></ul><h4 id="06-总结"><a href="#06-总结" class="headerlink" title="06 总结"></a>06 总结</h4><p>本文详细讲解了KNN算法，并与K-Means、K-Means++算法进行了对比，给出了KNN算法的三要素，最后介绍了便于KNN算法实现的kd树的数据存储结构。</p><ul><li><p>k近邻法过程<br>对给定的训练实例点和输入实例点，首先确定输入实例点的k个最近邻训练实例点，然后利用这k个训练实例点的类的多数（距离加权）来预测输入实例点的类</p></li><li><p>k近邻法三要素<br>距离度量、k值选择、分类决策规则</p></li><li><p>kd树<br>一种对k维空间中的实例点进行存储，以便对其进行快速检索的树形数据结构（这里的k维与k近邻的k意义不同）</p></li></ul><p><strong>下期将详细介绍另一种常用的分类方法：朴素贝叶斯，敬请期待~~</strong></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/4263204-d64e406b8eb190ad.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="统计学习方法" scheme="http://yoursite.com/categories/%E7%BB%9F%E8%AE%A1%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95/"/>
    
    
      <category term="统计学习方法" scheme="http://yoursite.com/tags/%E7%BB%9F%E8%AE%A1%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>统计学习方法 | 感知机</title>
    <link href="http://yoursite.com/2018/05/25/%E7%BB%9F%E8%AE%A1%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95-%E6%84%9F%E7%9F%A5%E6%9C%BA/"/>
    <id>http://yoursite.com/2018/05/25/统计学习方法-感知机/</id>
    <published>2018-05-25T07:12:12.000Z</published>
    <updated>2018-05-25T12:10:30.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://upload-images.jianshu.io/upload_images/4263204-c3ed2d6bf2f580f6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><a id="more"></a><h3 id="01-见证者"><a href="#01-见证者" class="headerlink" title="01 见证者"></a>01 见证者</h3><p>上一周我们了解了<a href="https://www.jianshu.com/p/9b39be467330" target="_blank" rel="noopener">统计学习方法的概念和基本的三要素</a></p><p>还记得三要素么？</p><blockquote><p>模型、策略、算法</p></blockquote><p>这周我们进入正题，对各个统计学习方法按照三要素的结构进行学习，先从机器学习最原始的方法说起——感知机。</p><p>稍微了解一下人工智能的发展历史，我们可以知道，感知机算法见证了人工智能领域的第一次低谷期，启发了后面的神经网络和支持向量机。</p><p>虽然我们已经不再使用感知机算法求解复杂问题，但了解其思路对于后面神经网络、支持向量机等算法的学习是非常必要的。</p><p>下面就一起来学习吧～</p><h3 id="02-感知机模型"><a href="#02-感知机模型" class="headerlink" title="02 感知机模型"></a>02 感知机模型</h3><p>感知机在1957年由Rosenblatt提出，是神经网络、支持向量机的基础，它是二分类的线性分类模型，属于判别模型。</p><p>我们来看看感知机的定义，</p><blockquote><p>由输入空间X到输出空间Y的如下函数称为感知机：</p><p>y=f(x)=sign(w.x+b)</p><ul><li>其中，w b为感知机模型参数，w为权值、权值向量weight vector，b为偏置bias，sign为符号函数，</li><li>sign(x)=+1,x&gt;=0;  -1,x&lt;0</li><li>分离超平面S：w.x+b=0</li></ul></blockquote><p><strong>感知机的目的是求出将训练数据集线性划分的分离超平面S。</strong></p><p>正如概论中所说，要达到感知机的目的，我们找到这个超平面的损失函数L(w,b)，利用梯度下降法对损失函数极小化，从而求得感知机模型。</p><p><img src="https://upload-images.jianshu.io/upload_images/4263204-3b9027a03906aeb4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><h3 id="03-感知机策略"><a href="#03-感知机策略" class="headerlink" title="03 感知机策略"></a>03 感知机策略</h3><p>学习策略，就是求解最佳超平面S的策略，</p><blockquote><p>可以概括为两步：</p><ol><li>定义损失函数</li><li>损失函数极小化</li></ol></blockquote><h6 id="定义损失函数"><a href="#定义损失函数" class="headerlink" title="定义损失函数"></a>定义损失函数</h6><p>感知机是0、1的二分类模型，直观来讲，其损失函数就是误分类点到分离超平面S的总距离，损失函数如下：</p><p><img src="https://upload-images.jianshu.io/upload_images/4263204-01fc4e3a94c680ab.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="感知机损失函数"></p><h6 id="损失函数最小化"><a href="#损失函数最小化" class="headerlink" title="损失函数最小化"></a>损失函数最小化</h6><p>损失函数已经定义，接下来就是将损失函数最小化的策略：在假设空间中选取使损失函数最小的模型参数w,b，从而得到感知机模型f(x)=sign(wx+b)</p><h3 id="04-感知机算法"><a href="#04-感知机算法" class="headerlink" title="04 感知机算法"></a>04 感知机算法</h3><p>算法其实就是损失函数最小化的具体计算方法，这里使用<strong>随机梯度下降法</strong>（如果有必要，后期可能会补充分享该内容）</p><p>感知机算法是基于随机梯度下降法的对损失函数的最优化算法，有原始形式和对偶形式，算法可以表示如下：</p><p><img src="https://upload-images.jianshu.io/upload_images/4263204-6fff419bb564c9e2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="感知机算法-极小化损失函数"></p><p>下面给出算法的原始形式</p><p><img src="https://upload-images.jianshu.io/upload_images/4263204-e876e5db3787c538.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>看了以上过程你可能还是很懵逼，那么我们对以上算法进行直观解释看看：</p><blockquote><p>当一个实例被误分类，即位于分离超平面S的错误一侧，则调整w b值，使分离超平面S向该误分类点的移动，以减少该误分类点与超平面S的距离，直至超平面越过该误分类点，使其被正确分类。</p></blockquote><p><img src="https://upload-images.jianshu.io/upload_images/4263204-bf93ef1bfb24225e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><h3 id="05-总结"><a href="#05-总结" class="headerlink" title="05 总结"></a>05 总结</h3><p><strong>简单总结一下感知机</strong></p><ul><li>感知机学习策略是极小化损失函数L(w,b)</li><li>感知机学习算法是基于随机梯度下降法的对损失函数的最优化算法，有原始形式和对偶形式</li><li>当训练数据集线性可分时，感知机学习算法是收敛的</li><li>当训练数据集线性可分时，感知机学习算法有无穷多个解，其解由于不同的初值或不同的迭代顺序而可能有所不同</li></ul><p>虽然对于复杂问题的求解，我们已经不再使用感知机方法，但感知机是神级网络和支持向量机的基础。</p><p>这周我们从感知机模型、策略、算法这三要素对感知机进行了解和学习，下周我们将对K近邻法(KNN)进行学习，敬请期待～</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/4263204-c3ed2d6bf2f580f6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="统计学习方法" scheme="http://yoursite.com/categories/%E7%BB%9F%E8%AE%A1%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95/"/>
    
    
      <category term="统计学习方法" scheme="http://yoursite.com/tags/%E7%BB%9F%E8%AE%A1%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>统计学习方法 | 概论</title>
    <link href="http://yoursite.com/2018/05/25/%E7%BB%9F%E8%AE%A1%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95-%E6%A6%82%E8%AE%BA/"/>
    <id>http://yoursite.com/2018/05/25/统计学习方法-概论/</id>
    <published>2018-05-25T07:11:12.000Z</published>
    <updated>2018-05-25T12:10:26.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://upload-images.jianshu.io/upload_images/4263204-ae2a8b686436052b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><a id="more"></a><h3 id="01-还不够"><a href="#01-还不够" class="headerlink" title="01 还不够"></a>01 还不够</h3><p>前段时间把Python的Pandas、Numpy、matplotlib、seaborn包拿来反复练习了一番，对于数据的观察、处理、清洗以及可视化有了一定的认识。</p><p>随着练习的深入，一个问题在我心中逐渐形成：</p><blockquote><p>一份数据的价值，通过清洗、多维度可视化就完全可以被展现出来了么？</p></blockquote><p><strong>还不够，还远远不够！</strong></p><p>于是我开始感受到知识储备的匮乏了。</p><p>还好前面有老司机带路，于是我琢磨着从理论基础入手，结合实操快速提升数据挖掘能力。</p><p>接下来的两到三个月，我会集中精力攻破李航的《统计学习方法》，本书共11章，计划1周1-2章（视章节情况而定），其中对于数据挖掘有帮助的知识，我会分享出来，与大家共勉~~</p><h3 id="02-三要素"><a href="#02-三要素" class="headerlink" title="02 三要素"></a>02 三要素</h3><p>不要被“统计学习”的名字误导，它不只是统计学，它的全名是“统计机器学习”，是计算机系统通过运用数据及统计方法提高系统性能的机器学习。</p><blockquote><p>统计学习三要素：</p><ol><li><strong>模型</strong>-在监督学习过程中，模型就是所要学习的条件概率分布P(Y|X)或决策函数y=f(X)，是一个假设空间</li><li><strong>策略</strong>-从假设空间中选取最优模型的过程，是将损失函数（期望风险、经验风险）最小化的策略</li><li><strong>算法</strong>-学习模型的具体计算方法，是求解最优化问题的算法</li></ol></blockquote><p><strong>确定了模型、策略、算法三要素，统计学习方法也就确定了，后面的所有章节，其实都是在探究具体问题的三要素。</strong></p><p><img src="https://upload-images.jianshu.io/upload_images/4263204-03fff2ccd4c3d7e1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><h3 id="03-模型的评估和选择"><a href="#03-模型的评估和选择" class="headerlink" title="03 模型的评估和选择"></a>03 模型的评估和选择</h3><p>选择模型，就是在选择假设空间，选择假设空间，就是在选择输入变量个数以及与输出变量可能的关系模型集合。</p><h5 id="过拟合"><a href="#过拟合" class="headerlink" title="过拟合"></a>过拟合</h5><p>我们选择的输入变量越多，那么对于已知数据的预测结果可能越准确，但是对于未知数据预测的准确性却会随着输入变量个数的增加而呈先增加后减少的结果，这就是过拟合</p><blockquote><p>学习时选择的模型所包含的参数太多，以至于出现这一模型对已知数据预测得很好，但对未知数据预测得很差的现象。</p></blockquote><h5 id="模型选择"><a href="#模型选择" class="headerlink" title="模型选择"></a>模型选择</h5><p>为了防止过拟合，模型选择时，不仅要考虑对已知数据的预测能力，还要考虑对未知数据的预测能力（泛化能力）。</p><p>防止过拟合，常用的方法有正则化和交叉验证。</p><h5 id="泛化能力"><a href="#泛化能力" class="headerlink" title="泛化能力"></a>泛化能力</h5><p>泛化能力是由学习方法学习得到的模型对于未知数据的预测能力，期望风险越小，泛化能力越强。</p><p>那么两种学习方法的优劣用什么指标来衡量呢？</p><p>答案是泛化误差上界，它指的是泛化误差概率的上限。</p><h5 id="两类模型"><a href="#两类模型" class="headerlink" title="两类模型"></a>两类模型</h5><p>机器学习中的监督学习，主要有两类模型划分：</p><ol><li><p>生成模型-由数据学习联合概率分布（概率密度函数）P(X,Y)，然后求出条件概率分布P(Y|X)作为预测的模型，即生成模型。</p></li><li><p>判别模型- 由数据直接学习决策函数f(X)或条件概率分布P(Y|X)作为预测的模型，即判别模型</p></li></ol><h6 id="生成模型-vs-判别模型"><a href="#生成模型-vs-判别模型" class="headerlink" title="生成模型 vs 判别模型"></a>生成模型 vs 判别模型</h6><p>相比于判别方法，生成方法可以还原出联合概率分布P(X,Y)；学习收敛速度更快；存在隐变量时也可以使用生成方法学习；</p><p>相比于生成方法，判别方法直接学习的时条件概率或决策函数，直接面对预测，往往学习的准确率更高；可以对数据进行各种程度上的抽象、定义特征等，简化学习问题</p><p>生成模型，更关心给定输入X产生输出Y的生成关系；<br>判别模型，更关心给定输入X，应该预测什么样的输出Y。</p><p><img src="https://upload-images.jianshu.io/upload_images/4263204-1556944de809888f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><h3 id="04-监督学习解决的三类代表性问题"><a href="#04-监督学习解决的三类代表性问题" class="headerlink" title="04 监督学习解决的三类代表性问题"></a>04 监督学习解决的三类代表性问题</h3><h5 id="分类问题（classify"><a href="#分类问题（classify" class="headerlink" title="分类问题（classify)"></a>分类问题（classify)</h5><p>定义：<br>当输出变量Y是有限个离散值时，预测问题便成为分类问题，此时的输入变量X可以时离散也可以是连续的。</p><p>过程：<br>学习-根据已知的训练数据集，利用有效的学习方法学习一个分类器（分类模型、分类决策函数）<br>分类-利用学习的分类器对新的输入实例进行分类</p><p><img src="https://upload-images.jianshu.io/upload_images/4263204-7e5040ddfc7b1eac.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><h5 id="标注问题（tagging）"><a href="#标注问题（tagging）" class="headerlink" title="标注问题（tagging）"></a>标注问题（tagging）</h5><p>定义：<br>学习一个模型，使它能够对观测序列给出标记序列作为预测。</p><p>过程：<br>学习-基于训练数据集构建一个模型，表示为条件概率分布<br>标注-按照学习到的条件概率分布模型，<br>对新的输入观测序列找到相应的输出标记序列</p><p><img src="https://upload-images.jianshu.io/upload_images/4263204-562b117e3535116f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><h5 id="回归问题（regression"><a href="#回归问题（regression" class="headerlink" title="回归问题（regression)"></a>回归问题（regression)</h5><p>定义：<br>用于预测输入变量和输出变量之间的关系，特别是当输入变量的值发生变化时，输出变量的值随之发生的变化。</p><p>过程：<br>学习-基于训练数据构建一个模型Y=f(X)<br>预测-对新的输入x，根据学习到的模型确定相应地输出</p><p><img src="https://upload-images.jianshu.io/upload_images/4263204-de75e499b31168aa.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><h3 id="05-预告"><a href="#05-预告" class="headerlink" title="05 预告"></a>05 预告</h3><p>本文总结了《统计学习方法》第一章内容，围绕统计学习三要素——模型、策略、算法，进行概念普及，后面的章节都会基于这三要素进行学习。</p><p>下周我会分享关于机器学习元老方法-感知机，以及常用方法-k近邻法的有关知识点，敬请期待~~</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/4263204-ae2a8b686436052b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="统计学习方法" scheme="http://yoursite.com/categories/%E7%BB%9F%E8%AE%A1%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95/"/>
    
    
      <category term="统计学习方法" scheme="http://yoursite.com/tags/%E7%BB%9F%E8%AE%A1%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Python | 数据可视化汇总</title>
    <link href="http://yoursite.com/2018/05/25/Python-%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96%E6%B1%87%E6%80%BB/"/>
    <id>http://yoursite.com/2018/05/25/Python-数据可视化汇总/</id>
    <published>2018-05-25T07:10:46.000Z</published>
    <updated>2018-05-25T12:10:02.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://upload-images.jianshu.io/upload_images/4263204-7dce65a5af881391.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><a id="more"></a><h3 id="01-提纲"><a href="#01-提纲" class="headerlink" title="01 提纲"></a>01 提纲</h3><p>不断总结是学习进步的阶梯。</p><p>前阵子针对python数据可视化进行了一波学习和实操，是时候总结一下数据可视化的方法和代码了，一起来复习吧！</p><p>想要说明的一点是，方法千千万，是学习不完的，怎么办呢？</p><p>最近听到一个词：<strong>用以致学</strong>。就是以目的为导向去学习，学到之后再进行总结，而不是盲目地学。</p><blockquote><p><strong>本次数据可视化复习提纲如下：</strong></p><ol><li>散点图</li><li>箱线图</li><li>折线图</li><li>条形图、直方图</li><li>饼图</li><li>多图</li></ol><p>主要使用到matplotlib.pyplot和seaborn两个python内置绘图包。</p></blockquote><p>下面我们开始吧~</p><p>对了，别忘记引入包<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">import matplotlib.pyplot as plt</span><br><span class="line">import seaborn as sns</span><br><span class="line">import numpy as np</span><br><span class="line">import pandas as pd</span><br><span class="line"></span><br><span class="line">#设置在notebook中直接展示图形输出</span><br><span class="line">%matplotlib inline</span><br><span class="line">#设置图片清晰度</span><br><span class="line">%config InlineBackend.figure_format=&quot;retina&quot;</span><br></pre></td></tr></table></figure></p><h3 id="02-散点图"><a href="#02-散点图" class="headerlink" title="02 散点图"></a>02 散点图</h3><p><strong>【.plot作图】</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># kind=&quot;scatter&quot;,做散点图，x轴表示花瓣长度，y轴表示花瓣宽度</span><br><span class="line">iris.plot(kind=&quot;scatter&quot;,color=&quot;red&quot;,x=&quot;petal_length&quot;,y=&quot;petal_width&quot;)</span><br></pre></td></tr></table></figure></p><p><strong>【matlibplot.pyplot.plot作图】 [plt.plot( )]</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">plt.style.use(&apos;ggplot&apos;)</span><br><span class="line"></span><br><span class="line">#设置画布大小</span><br><span class="line">plt.figure(figsize=(8,6))</span><br><span class="line"></span><br><span class="line">#scatter绘制散点图，s设置点大小</span><br><span class="line">plt.scatter(x=top10.Purchases,y=top10.Sales,s=100)</span><br></pre></td></tr></table></figure></p><p><strong>【seaborn作图】[sns.]  v.s. 【.plt作图】</strong></p><ol><li>matplotlib是python的主要绘图工具，但其自身的语法比较复杂</li><li>Seaborn是基于matplotlib产生的一个模块，专攻于统计可视化</li><li>Seaborn和matplotlib的关系类似于pandas和numpy的关系</li></ol><p>我们来看看seaborn相较于plt的简洁之处，下面两个代码实现同样的效果——花瓣长宽散点图，以品种划分数据.</p><p><strong>seaborn实现</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># FacetGrid中的hue参数指明划分数据的变量，这里是species（品种）</span><br><span class="line"># \ 用于将一行语句提行</span><br><span class="line"># add_legend()添加图例</span><br><span class="line">#先将iris数据集以species字段划分开</span><br><span class="line"></span><br><span class="line">sns.FacetGrid(iris,hue=&apos;species&apos;,size=7)\</span><br><span class="line">.map(plt.scatter,&apos;petal_length&apos;,&apos;petal_width&apos;).add_legend()</span><br></pre></td></tr></table></figure></p><p><strong>plt实现</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"># 使用布尔型索引，分别获取三种类型鸢尾花的数据集</span><br><span class="line">setosa=iris[iris.species==&quot;Iris-setosa&quot;]</span><br><span class="line">versicolor=iris[iris.species==&quot;Iris-versicolor&quot;]</span><br><span class="line">virginica=iris[iris.species==&quot;Iris-virginica&quot;]</span><br><span class="line"></span><br><span class="line">#作图，setosa数据散点图ax</span><br><span class="line">bx = setosa.plot(kind=&quot;scatter&quot;,x=&quot;petal_length&quot;,y=&quot;petal_width&quot;,color=&quot;red&quot;,label=&quot;setosa&quot;,figsize=(10,6))</span><br><span class="line">#将其余两种类型的花数据也作图在ax上</span><br><span class="line">versicolor.plot(ax=bx,kind=&quot;scatter&quot;,x=&quot;petal_length&quot;,y=&quot;petal_width&quot;,color=&quot;blue&quot;,label=&quot;versicolor&quot;)</span><br><span class="line">virginica.plot(ax=bx,kind=&quot;scatter&quot;,x=&quot;petal_length&quot;,y=&quot;petal_width&quot;,color=&quot;yellow&quot;,label=&quot;virginica&quot;)</span><br></pre></td></tr></table></figure></p><p><img src="https://upload-images.jianshu.io/upload_images/4263204-03a68b6a271462ec.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><h3 id="03-箱线图"><a href="#03-箱线图" class="headerlink" title="03 箱线图"></a>03 箱线图</h3><p>箱线图体现数据的最大、最小值，中位数、上下四分位数，是一个数据集的统计结果可视化。</p><p><strong>【.plot作图】</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># 指定某列数据，作单个箱线图</span><br><span class="line"># kind=&quot;box&quot;作箱图</span><br><span class="line">iris.petal_width.plot(kind=&quot;box&quot;,label=&quot;iris&quot;,figsize=(8,4))</span><br></pre></td></tr></table></figure><p><strong>【seaborn作图】[sns.]</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 花萼宽度箱线图，以品种划分数据</span><br><span class="line">sns.boxplot(data=iris,x=&apos;species&apos;,y=&apos;sepal_width&apos;)</span><br><span class="line"></span><br><span class="line">#下面语句实现与sns.boxplot一样的效果</span><br><span class="line">iris[[&quot;sepal_width&quot;,&quot;species&quot;]].boxplot(grid=False,by=&quot;species&quot;)</span><br></pre></td></tr></table></figure><p><img src="https://upload-images.jianshu.io/upload_images/4263204-7978a6d11b0e0dfa.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><h3 id="04-折线图"><a href="#04-折线图" class="headerlink" title="04 折线图"></a>04 折线图</h3><p><strong>【matlibplot.pyplot.plot作图】 [plt.]</strong><br>plt拥有很多内置函数可调用，对于美化图片、设置标识等都比较方便。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">#绘制折线图</span><br><span class="line">plt.plot(rank1m.year,rank1m.pct,color=&quot;blue&quot;,linewidth=2)</span><br><span class="line"></span><br><span class="line">#plt.fill_between设置填充线与坐标轴之间的空间</span><br><span class="line">plt.fill_between(rank1m.year,rank1m.pct,color=&quot;blue&quot;,alpha=0.2)</span><br><span class="line"></span><br><span class="line">#设置坐标轴区间范围</span><br><span class="line">plt.xlim(1880,2016)</span><br><span class="line">plt.ylim(0,9)</span><br><span class="line"></span><br><span class="line">#美化图：给图添加标题，调整字体大小等</span><br><span class="line">plt.title(&quot;Popularity of 1# boys&apos;name by year&quot;,size=18,color=&quot;blue&quot;)</span><br><span class="line">plt.xlabel(&quot;Year&quot;,size=16)</span><br><span class="line">plt.ylabel(&quot;% of male births&quot;,size=16)</span><br></pre></td></tr></table></figure></p><p><img src="https://upload-images.jianshu.io/upload_images/4263204-922f60ac87869e48.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><h3 id="05-条形图、直方图"><a href="#05-条形图、直方图" class="headerlink" title="05 条形图、直方图"></a>05 条形图、直方图</h3><p><strong>【matlibplot.pyplot.plot作图】 [plt.]</strong><br>barh-水平条形图<br>bar-垂直条形图<br>hist-直方图</p><p><strong>绘制水平条形图</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">plt.style.use(&apos;ggplot&apos;)</span><br><span class="line"></span><br><span class="line">#barh绘制水平条形图；bar绘制垂直直方图</span><br><span class="line">&quot;&quot;&quot;注意，条形图条数np.arange(10),要与top10.Sales数据数量一致，否则会报错-形状不匹(shape mismatch)&quot;&quot;&quot;</span><br><span class="line">plt.barh(np.arange(10),top10.Sales,height=0.6)</span><br><span class="line"></span><br><span class="line">#添加标题</span><br><span class="line">plt.title(&apos;Top 10 Sales Company&apos;)</span><br><span class="line">plt.xlabel(&apos;Total Revenue&apos;)</span><br><span class="line">plt.ylabel(&apos;Company&apos;)</span><br><span class="line"></span><br><span class="line">#修改纵坐标、横坐标刻度</span><br><span class="line">&apos;&apos;&apos;此语句，可用tick_label=top10.Company替代，替代语句放在plt.barh()参数中</span><br><span class="line">例如：plt.barh(np.arange(10),top10.Sales,tick_label=top10.Company,height=0.8) &apos;&apos;&apos;</span><br><span class="line">plt.yticks(np.arange(10),top10.Company)</span><br><span class="line">plt.xticks([0,20000,40000,60000,80000,100000,120000,140000],</span><br><span class="line">          [&apos;$0k&apos;,&apos;$20k&apos;,&apos;$40k&apos;,&apos;$60k&apos;,&apos;$80k&apos;,&apos;$100k&apos;,&apos;$120k&apos;,&apos;$140k&apos;])</span><br><span class="line"></span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure></p><p><img src="https://upload-images.jianshu.io/upload_images/4263204-f3eb50008c0290d0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p><strong>绘制直方图</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># 对于原始数据df中，每笔订单的交易额(ext price)，统计单笔订单交易额分布情况</span><br><span class="line"></span><br><span class="line">#hist绘制直方图，bins设置区间个数</span><br><span class="line">plt.hist(df[&apos;ext price&apos;],bins=20,rwidth=0.8)</span><br><span class="line"></span><br><span class="line">plt.xlim(-200, 5000)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure></p><p><img src="https://upload-images.jianshu.io/upload_images/4263204-2d9f12629ec9865c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><h3 id="06-饼图"><a href="#06-饼图" class="headerlink" title="06 饼图"></a>06 饼图</h3><p><strong>【matlibplot.pyplot.plot作图】 [plt.]</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"> #plt.pie()绘制饼图</span><br><span class="line"></span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line"></span><br><span class="line">labels代表每个扇区的标签，</span><br><span class="line"></span><br><span class="line">colors=[&apos;b&apos;,&apos;g&apos;],设置扇区颜色</span><br><span class="line"></span><br><span class="line">startangle代表起始位置角度</span><br><span class="line"></span><br><span class="line">explode=(0.1,0,0,0,0,0,0,0,0,0)代表将第一个扇区拉出来0.1，作为突出显示</span><br><span class="line"></span><br><span class="line">autopct=&apos;%1.1f%%&apos;,代表给出每个扇区的占比 ，精确到小数点后1位</span><br><span class="line"></span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line"></span><br><span class="line">plt.pie(top10.Sales,labels=[top10.Company](http://top10.company/),</span><br><span class="line"></span><br><span class="line">        colors=[&apos;r&apos;,&apos;y&apos;,&apos;b&apos;,&apos;g&apos;,&apos;c&apos;,&apos;r&apos;,&apos;y&apos;,&apos;b&apos;,&apos;g&apos;,&apos;c&apos;],</span><br><span class="line"></span><br><span class="line">        startangle=90,</span><br><span class="line"></span><br><span class="line">        explode=(0.1,0,0,0,0,0,0,0,0,0),</span><br><span class="line"></span><br><span class="line">        autopct=&apos;%1.1f%%&apos;)</span><br><span class="line"></span><br><span class="line">#使饼图呈圆形</span><br><span class="line"></span><br><span class="line">plt.axis(&apos;equal&apos;)</span><br></pre></td></tr></table></figure><p><img src="https://upload-images.jianshu.io/upload_images/4263204-a5a7f916fbc3be05.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><h3 id="07-绘制多图"><a href="#07-绘制多图" class="headerlink" title="07 绘制多图"></a>07 绘制多图</h3><p>在一张画布上，绘制多张图片，更加方便对比分析。</p><p><strong>【matlibplot.pyplot.plot作图】 [plt.]</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">plt.style.use(&apos;ggplot&apos;)</span><br><span class="line">#设置画布大小</span><br><span class="line">fig=plt.figure(figsize=(12,12))</span><br><span class="line"></span><br><span class="line">#加上图像大标题</span><br><span class="line">fig.suptitle(&apos;Sales Analysis&apos;,fontsize=16,fontweight=&apos;bold&apos;)</span><br><span class="line"></span><br><span class="line">#fig.add_subplot(x,y,z),表示将画布分为x行,y列,当前图像放在从左到右、从上到下的第z个位置</span><br><span class="line"></span><br><span class="line">#添加第一个子图</span><br><span class="line">ax1=fig.add_subplot(2,2,1)</span><br><span class="line">plt.barh(np.arange(10),top10.Sales,height=0.5,tick_label=top10.Company)</span><br><span class="line">plt.title(&apos;Revenue&apos;)</span><br><span class="line"></span><br><span class="line">#加入平均销售额线  plt.axvline()表示添加垂直线axis vertical line</span><br><span class="line">revenue_avg=top10.Sales.mean()</span><br><span class="line">plt.axvline(x=revenue_avg,color=&apos;b&apos;,linestyle=&apos;--&apos;,linewidth=3)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#添加第二个子图</span><br><span class="line">ax2=fig.add_subplot(222)</span><br><span class="line">plt.barh(np.arange(10),top10.Purchases,height=0.5)</span><br><span class="line">plt.title(&apos;Purchases&apos;)</span><br><span class="line"></span><br><span class="line">#设置不显示y轴刻度</span><br><span class="line">plt.yticks(visible=False)</span><br><span class="line"></span><br><span class="line">#加入平均订单数线</span><br><span class="line">Purchases_avg=top10.Purchases.mean()</span><br><span class="line">plt.axvline(x=Purchases_avg,color=&apos;b&apos;,linestyle=&apos;--&apos;,linewidth=3)</span><br><span class="line"></span><br><span class="line">#加入第三个、第四个子图</span><br><span class="line">ax3=fig.add_subplot(223)</span><br><span class="line">plt.barh(np.arange(10),top10.Sales,height=0.5,tick_label=top10.Company)</span><br><span class="line">plt.title(&apos;Revenue&apos;)</span><br><span class="line"></span><br><span class="line">ax4=fig.add_subplot(224)</span><br><span class="line">plt.pie(top10.Sales,labels=top10.Company,</span><br><span class="line">        colors=[&apos;r&apos;,&apos;y&apos;,&apos;b&apos;,&apos;g&apos;,&apos;c&apos;,&apos;r&apos;,&apos;y&apos;,&apos;b&apos;,&apos;g&apos;,&apos;c&apos;],</span><br><span class="line">        startangle=90,</span><br><span class="line">        explode=(0.1,0,0,0,0,0,0,0,0,0),</span><br><span class="line">        autopct=&apos;%1.1f%%&apos;)</span><br><span class="line">plt.axis(&apos;equal&apos;)</span><br><span class="line"></span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure></p><p><img src="https://upload-images.jianshu.io/upload_images/4263204-08e46a5543cb1342.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p><strong>【seaborn作图】[sns.]</strong></p><ol><li>sns.pairplot实现</li><li>用于快速观察各变量的分布情况，关系等</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 一条语句，展现4个变量之间的关系</span><br><span class="line"># 分别展示了4个变量分布的直方图；以及两两变量之间的散点图</span><br><span class="line"></span><br><span class="line">sns.pairplot(iris,hue=&apos;species&apos;)</span><br></pre></td></tr></table></figure><p><img src="https://upload-images.jianshu.io/upload_images/4263204-86ca2464291f471b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><h3 id="08-总结"><a href="#08-总结" class="headerlink" title="08 总结"></a>08 总结</h3><p>本文完整梳理了数据分析中常用的几种图的python绘制方法。</p><blockquote><p>主要涉及到以下几种图的绘制：</p><ol><li>散点图</li><li>箱线图</li><li>折线图</li><li>条形图、直方图</li><li>饼图</li><li>多图</li></ol></blockquote><blockquote><p>主要使用到的绘图包</p><ol><li>matplotlib.pyplot</li><li>seaborn</li></ol></blockquote><p>当然，条条大路通罗马，方法是学不完的，一定要以目的为导向学习技能，希望对你有帮助。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/4263204-7dce65a5af881391.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="PYTHON" scheme="http://yoursite.com/categories/PYTHON/"/>
    
    
      <category term="python" scheme="http://yoursite.com/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>Python|美国婴儿姓名分析</title>
    <link href="http://yoursite.com/2018/05/25/Python-%E7%BE%8E%E5%9B%BD%E5%A9%B4%E5%84%BF%E5%A7%93%E5%90%8D%E5%88%86%E6%9E%90/"/>
    <id>http://yoursite.com/2018/05/25/Python-美国婴儿姓名分析/</id>
    <published>2018-05-25T07:09:35.000Z</published>
    <updated>2018-05-25T12:09:52.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://upload-images.jianshu.io/upload_images/4263204-95241e1dc12b3b72.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><a id="more"></a><h3 id="01-引子"><a href="#01-引子" class="headerlink" title="01 引子"></a>01 引子</h3><p>今天咱们来实操上一课的内容。</p><p>还记得上一课的内容么？</p><blockquote><p>上课我们学习了python pandas包中的groupby方法，如果记不清了可以点击这里回顾哦：<br><a href="https://www.jianshu.com/p/2432a8d2c006" target="_blank" rel="noopener">groupby方法详细讲解</a></p></blockquote><p><em>之前的文章有朋友反馈说更愿意在文章中看到讲解内容而不是链接地址，那么我们今天就把github中的内容搬到这里来吧，希望可以更好地帮助大家学习python～</em></p><h3 id="02-动手实操吧"><a href="#02-动手实操吧" class="headerlink" title="02 动手实操吧"></a>02 动手实操吧</h3><p>这里我们拿到一份1880-2016这136年间美国婴儿取名的数据(<a href="https://www.ssa.gov/oact/babynames/limits.html" target="_blank" rel="noopener">数据源在这里下载</a>），数据总共有189万条，57.7M的大小，如我们之前所说，这样的数据量Excel已经吃不消了。</p><p><strong>所以我们用Python！</strong></p><p>首先读取1880-2016年的取名数据，由于每年的数据是一个独立的dataframe，因此我们使用concat()方法将各年数据整合为一个dataframe<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">import pandas as pd</span><br><span class="line"></span><br><span class="line">#读取1880-2016年婴儿姓名使用信息，由于信息表按年统计，因此需要将多年数据整合到一张表中</span><br><span class="line">years=range(1880,2017)</span><br><span class="line">columns=[&quot;name&quot;,&quot;gender&quot;,&quot;frequency&quot;]</span><br><span class="line">pieces=[] #用于存储循环读取的每一年的数据,list中的每个元素代表一年的数据</span><br><span class="line"></span><br><span class="line">#使用循环读取每年数据，并将各年数据都存入pieces中,pieces列表的各元素表示各年的数据</span><br><span class="line">for year in years:</span><br><span class="line">    path=&quot;/Users/dengsudden/Documents/python_course/names/yob%d.txt&quot; %year</span><br><span class="line">    frame=pd.read_csv(path,names=columns)</span><br><span class="line">    frame[&quot;year&quot;]=year</span><br><span class="line">    pieces.append(frame)</span><br><span class="line"></span><br><span class="line">#中pieces列表中填入各年数据后，需要使用concat方法将pieces各元素整合在一起</span><br><span class="line">baby_names=pd.concat(pieces,ignore_index=True)</span><br><span class="line"></span><br><span class="line">baby_names.tail()</span><br></pre></td></tr></table></figure></p><p>输出结果如下，这是数据表的最后5行，输出方便大家观察数据表结构：<img src="http://upload-images.jianshu.io/upload_images/4263204-058085a48483c642.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><h4 id="接下来我们正式开始实操"><a href="#接下来我们正式开始实操" class="headerlink" title="接下来我们正式开始实操"></a>接下来我们正式开始实操</h4><p><strong>1. 统计不同年份、不同性别分组下，各名字出现次数所占分组人数比例</strong></p><p>思路：这里我们先自定义了一个函数dd_pct，然后使用了groupby按年份、性别分组，最后分别对每个分组调用我们的自定义函数add_pct</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#先自定义函数，统计分组中各名字占比</span><br><span class="line">def add_pct(group):</span><br><span class="line">    group[&quot;pct&quot;]=group.frequency/group.frequency.sum()*100</span><br><span class="line">    return group</span><br><span class="line"></span><br><span class="line">baby_names=baby_names.groupby([&quot;year&quot;,&quot;gender&quot;]).apply(add_pct)</span><br><span class="line">baby_names.head()</span><br></pre></td></tr></table></figure><p>输出结果如下，可以看到，数据表中增加了一列pct，代表各名字出现次数在分组中的比例：<img src="http://upload-images.jianshu.io/upload_images/4263204-37d2bbcc0c3009e4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p><strong>2. 排名：给出不同年份、不同性别分组下，各名字在分组中出现频率的排名</strong></p><p>思路：现将数据按年份、性别分组，然后对分组数据的frequency列调用rank()方法降序得到排名，并将排名赋到新增的“ranked”列<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">baby_names[&quot;ranked&quot;]=baby_names.groupby([&quot;year&quot;,&quot;gender&quot;])[&quot;frequency&quot;].rank(ascending=False)</span><br><span class="line">baby_names.head()</span><br></pre></td></tr></table></figure></p><p>输出结果如下：<img src="http://upload-images.jianshu.io/upload_images/4263204-1ffdbf3fd2b39c2b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p><strong>3. 可视化：每年最流行的男孩女孩名字的使用次数所占当年出生男孩女孩总数的比例</strong></p><p>思路：首先使用布尔型索引将数据分为男孩数据、女孩数据（注意，这时的数据中已经有ranked排名这一列了），对于男孩数据，选出每年出现频率最高的名字（ranked==1），然后按照x-y=year-pct作图，女孩数据同理。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">import matplotlib.pyplot as plt</span><br><span class="line">%matplotlib inline</span><br><span class="line">%config InlineBackend.figure_format=&quot;retina&quot;</span><br><span class="line"></span><br><span class="line">#布尔索引选取数据中的男孩女孩</span><br><span class="line">dfm=baby_names[baby_names.gender==&quot;M&quot;]</span><br><span class="line">dff=baby_names[baby_names.gender==&quot;F&quot;]</span><br><span class="line"></span><br><span class="line">#每年最流行的男孩名字</span><br><span class="line">rank1m=dfm[dfm.ranked==1]</span><br><span class="line">#每年最流行的女孩名字</span><br><span class="line">rank1f=dff[dff.ranked==1]</span><br></pre></td></tr></table></figure></p><p>输出结果如下，这里只输出了前5行数据：<img src="http://upload-images.jianshu.io/upload_images/4263204-b0b3dbd64d9747b2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><img src="http://upload-images.jianshu.io/upload_images/4263204-a599da9e905f6fae.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p><strong>接下来我们对以上数据可视化，从而对于最流行的名字的占比趋势有个直观的了解。</strong></p><p>方法：调用matplotlib包，具体使用方法如下。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">#绘制折线图</span><br><span class="line">plt.plot(rank1m.year,rank1m.pct,color=&quot;blue&quot;,linewidth=2)</span><br><span class="line"></span><br><span class="line">#plt.fill_between设置填充线与坐标轴之间的空间</span><br><span class="line">plt.fill_between(rank1m.year,rank1m.pct,color=&quot;blue&quot;,alpha=0.2)</span><br><span class="line"></span><br><span class="line">#设置坐标轴区间范围</span><br><span class="line">plt.xlim(1880,2016)</span><br><span class="line">plt.ylim(0,9)</span><br><span class="line"></span><br><span class="line">#美化图：给图添加标题，调整字体大小等</span><br><span class="line">plt.title(&quot;Popularity of 1# boys&apos;name by year&quot;,size=18,color=&quot;blue&quot;)</span><br><span class="line">plt.xlabel(&quot;Year&quot;,size=16)</span><br><span class="line">plt.ylabel(&quot;% of male births&quot;,size=16)</span><br></pre></td></tr></table></figure></p><p>输出结果如下：<img src="http://upload-images.jianshu.io/upload_images/4263204-74712210aab81f19.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>女孩姓名同理，输出结果如下：<img src="http://upload-images.jianshu.io/upload_images/4263204-b2c070fb10cd8d43.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>根据以上输出结果，我们发现，不论是男孩还是女孩，每年最流行的名字所占当年分组出生人数比例都在下降，是什么原因导致的呢？</p><ul><li>民众的思想更加自主，越来越个性化</li><li>还有一个原因可能是每年可选择的姓名数越来越多了，下面我们用统计结果来证明</li></ul><p><strong>4. 可视化：每年可选择的姓名数量趋势图</strong></p><p>思路：按年份、性别分组，统计各分组下的姓名数量，然后根据按年份，绘制不同性别各年度可选姓名数量的趋势图<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">name_count=baby_names.groupby([&quot;year&quot;,&quot;gender&quot;]).size() #.size()返回一个series</span><br><span class="line">#使用to_frame将series转换为dataframe</span><br><span class="line">name_count=name_count.to_frame(name=&quot;name_count&quot;).reset_index()</span><br><span class="line"></span><br><span class="line">#将数据按男女分组</span><br><span class="line">name_countm=name_count[name_count.gender==&quot;M&quot;]</span><br><span class="line">name_countf=name_count[name_count.gender==&quot;F&quot;]</span><br></pre></td></tr></table></figure></p><p>name_count的前5行输出结果如下：<img src="http://upload-images.jianshu.io/upload_images/4263204-bad2fa5c5e00112f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p><strong>接下来根据统计结果绘图</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">plt.plot(name_countm.year,name_countm.name_count,color=&quot;blue&quot;,linewidth=2)</span><br><span class="line">plt.fill_between(name_countm.year,name_countm.name_count,color=&quot;blue&quot;,alpha=0.2)</span><br><span class="line">plt.xlim(1880,2016)</span><br><span class="line">plt.ylim(0,17000)</span><br><span class="line">plt.title(&quot;Number of boy&apos;s name by year&quot;,size=20,color=&quot;blue&quot;)</span><br><span class="line">plt.xlabel(&quot;Year&quot;,size=18)</span><br><span class="line">plt.ylabel(&quot;Number of names&quot;,size=18)</span><br></pre></td></tr></table></figure></p><p>趋势图如下：<img src="http://upload-images.jianshu.io/upload_images/4263204-da83fa3c2d3adf86.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><img src="http://upload-images.jianshu.io/upload_images/4263204-a87d85f65f09bc2c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>通过以上验证可以看到，不论男女，可选名字数量逐年递增，这可能也是导致每年最流行的名字占比当年出生人口比例逐年下降的因素之一。（当然，这也可能是民众思想解放，创造力爆发的结果）</p><h3 id="03-结语"><a href="#03-结语" class="headerlink" title="03 结语"></a>03 结语</h3><p>今天我们一起针对python pandas包进行了实操，特别是对于groupby和matplotlib可视化的练习。</p><p>实操代码我放在了github上，里面有更加详细的说明和一些作业练习，如果没有看过瘾可以点进github中看看</p><blockquote><p><a href="https://github.com/Suddennebbus/Python_Learning/blob/master/Lesson6%20%E6%A1%88%E4%BE%8B%20%E7%BE%8E%E5%9B%BD%E5%A9%B4%E5%84%BF%E5%90%8D%E5%AD%97%E6%95%B0%E6%8D%AE.ipynb" target="_blank" rel="noopener">实操代码</a></p></blockquote><p>希望对你有帮助～～</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/4263204-95241e1dc12b3b72.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="PYTHON" scheme="http://yoursite.com/categories/PYTHON/"/>
    
    
      <category term="python" scheme="http://yoursite.com/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>Python|餐厅小费比例分析</title>
    <link href="http://yoursite.com/2018/05/25/Python-%E9%A4%90%E5%8E%85%E5%B0%8F%E8%B4%B9%E6%AF%94%E4%BE%8B%E5%88%86%E6%9E%90/"/>
    <id>http://yoursite.com/2018/05/25/Python-餐厅小费比例分析/</id>
    <published>2018-05-25T07:08:51.000Z</published>
    <updated>2018-05-25T12:09:34.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://upload-images.jianshu.io/upload_images/4263204-b9807e77797c67ca.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><a id="more"></a><h3 id="01-引"><a href="#01-引" class="headerlink" title="01 引"></a>01 引</h3><p>我们手里有一份餐厅统计的用餐信息，包括餐费、小费、性别、吸烟习惯、用餐时段、用餐人数等信息。下面让我们用这份数据表练手python吧。</p><p><strong>本次练习主要围绕一下几点：</strong></p><blockquote><ol><li>groupby方法</li><li>plot箱线图</li><li>plot散点图</li></ol></blockquote><p>来吧，让我们开始吧！</p><p><strong>目的：分析小费比例与其他因素的关系，出手最阔绰的人群长什么样？</strong></p><h3 id="02-实操"><a href="#02-实操" class="headerlink" title="02 实操"></a>02 实操</h3><p>其实根据这份数据可以分析出很多好玩的东西，比如：</p><blockquote><ul><li>餐费高低与性别、用餐时段、用餐日期的关系</li><li>吸烟顾客的画像、不吸烟顾客的画像</li><li>小费比例与性别、吸烟习惯、用餐时段等因素的关系</li></ul></blockquote><p>篇幅有限，举一反三，今天我们就来看看小费比例与性别、吸烟习惯、用餐时段等因素的关系吧。</p><h4 id="2-1-数据结构"><a href="#2-1-数据结构" class="headerlink" title="2.1 数据结构"></a>2.1 数据结构</h4><p>首先我们来看看这份数据长什么样<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">import pandas as pd</span><br><span class="line">%matplotlib inline</span><br><span class="line">%config InlineBackend.figure_format=&quot;retina&quot;</span><br><span class="line"></span><br><span class="line">tips=pd.read_csv(&quot;/Users/dengsudden/Documents/python_course/tips.csv&quot;,sep=&quot;;&quot;)</span><br><span class="line">tips.head()</span><br></pre></td></tr></table></figure></p><p><img src="http://upload-images.jianshu.io/upload_images/4263204-368ddf02f28e45aa.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>其中，各字段意义如下：</p><ul><li>total_bill：账单总额</li><li>tip: 所付小费</li><li>sex: 性别</li><li>smoker：是否吸烟</li><li>day：周一至周日的一天</li><li>time：晚餐(dinner)还是午餐(lunch)</li><li>size: 用餐人数</li></ul><p>我们还可以通过一个散点图更直观地感受数据情况。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tipa.plot(kind=&quot;scatter&quot;,x=&quot;total_bill&quot;,y=&quot;tip&quot;,color=&quot;blue&quot;,label=&quot;bill_tip&quot;,figsize=(10,6))</span><br></pre></td></tr></table></figure></p><p><img src="http://upload-images.jianshu.io/upload_images/4263204-bb471c590cb5edfd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>横轴表示消费额，纵轴表示小费，可以大致看到一个趋势——小费随消费额的增加而增加。（不过后面的分析我们会发现，小费比例随消费额的增加而减少）</p><h4 id="2-2-分析思路"><a href="#2-2-分析思路" class="headerlink" title="2.2 分析思路"></a>2.2 分析思路</h4><ol><li>首先计算出小费比例</li><li>提出假设：小费比例与消费额成正比，与用餐人数成正比，有吸烟习惯的人小费比例更高，男性比女性小费比例高，晚餐比午餐小费比例高，周末小费比例更高</li><li>验证假设</li></ol><h4 id="2-3-数据清洗"><a href="#2-3-数据清洗" class="headerlink" title="2.3 数据清洗"></a>2.3 数据清洗</h4><p><strong>首先来看看离群值是否是异常值，思路如下：</strong></p><ol><li>画出整体数据小费比例的箱线图，可以看到离群值</li><li>根据箱线图中离群值范围，找出离群值具体数据情况，判别是否为异常值</li><li>使用df.drop([index1,index2,])去除数据中的异常值</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 计算小费比例</span><br><span class="line">tips[&quot;pct&quot;]=tips.tip/tips.total_bill*100</span><br><span class="line">tips.head()</span><br><span class="line"></span><br><span class="line">#整体数据的小费比例箱线图</span><br><span class="line">tips.pct.plot(kind=&quot;box&quot;,label=&quot;tips pct%&quot;,figsize=(10,6))</span><br></pre></td></tr></table></figure><p><img src="http://upload-images.jianshu.io/upload_images/4263204-dad44b01ea1dd1de.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br>从整体数据来看，小费比例最小在3%左右，最大在70%左右，中位数在15%左右，均值为16%，这是一个很大的范围，我们需要深入到各个纬度去研究小费比例的关联因素。小费比例高于30%被认为是离群值，下面我看来看看这几个离群值是否是异常值。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tips[tips.pct&gt;30]</span><br></pre></td></tr></table></figure><p><img src="http://upload-images.jianshu.io/upload_images/4263204-7312f388a3eee1e9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>可以看到，小费比例较高的这几个离群值，小费总额都不到10美元，而小费比例就超出一半，可以认为这是异常值，因此我们剔除掉这些异常值。然后再开始数据挖掘。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># 去除异常值</span><br><span class="line">tipa=tips.drop([67,172,178])</span><br><span class="line">tipa[tipa.pct&gt;30]</span><br></pre></td></tr></table></figure></p><h4 id="2-4-正题来了：数据挖掘"><a href="#2-4-正题来了：数据挖掘" class="headerlink" title="2.4 正题来了：数据挖掘"></a>2.4 正题来了：数据挖掘</h4><ul><li>小费比例与性别、日期、吸烟习惯、用餐时段的关系<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">#按男女分组，绘制小费比例箱线图</span><br><span class="line">tipa[[&quot;pct&quot;,&quot;sex&quot;]].boxplot(grid=False,by=&quot;sex&quot;,figsize=(10,6))</span><br><span class="line"></span><br><span class="line">#按星期几分组，绘制小费比例箱线图</span><br><span class="line">tipa[[&quot;pct&quot;,&quot;day&quot;]].boxplot(grid=False,by=&quot;day&quot;,figsize=(10,6))</span><br><span class="line"></span><br><span class="line"># 是否吸烟与小费比例关系</span><br><span class="line">tipa[[&quot;pct&quot;,&quot;smoker&quot;]].boxplot(grid=False,by=&quot;smoker&quot;,figsize=(10,6))</span><br><span class="line"></span><br><span class="line"># 按性别分组，寻找吸烟与否与小费比例关系</span><br><span class="line">tipsm=tipa[tipa.sex==&quot;Male&quot;]</span><br><span class="line">tipsf=tipa[tipa.sex==&quot;Female&quot;]</span><br><span class="line"></span><br><span class="line">tipsm[[&quot;pct&quot;,&quot;smoker&quot;]].boxplot(grid=False,by=&quot;smoker&quot;,figsize=(10,6))</span><br><span class="line">tipsf[[&quot;pct&quot;,&quot;smoker&quot;]].boxplot(grid=False,by=&quot;smoker&quot;,figsize=(10,6))</span><br><span class="line"></span><br><span class="line">#小费比例与用餐时段的关系</span><br><span class="line">tipa[[&quot;pct&quot;,&quot;time&quot;]].boxplot(grid=False,by=&quot;time&quot;,figsize=(10,6))</span><br></pre></td></tr></table></figure></li></ul><p>输出如下（仅挑选有意义的输出）：<br><img src="http://upload-images.jianshu.io/upload_images/4263204-6339d12defd7a819.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>按性别分组来看，男女性的中位数接近，男性的小费比例分布非常均匀，女性的小费比例下四分位数更加靠上，说明女性更容易给出更高的小费。</p><p><img src="http://upload-images.jianshu.io/upload_images/4263204-a7751a4a10781527.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>按日期分组来看，周四到周天的小费比例中位数区别不大，节假日的周六周天人们给小费更加随意一点，特别是周六，小费比例范围跨度达到了25%，原因可能在于周末人们拥有更加轻松愉快的心情（说不定周末相亲的人也更多，小费比例高呢）。而这两天也更容易出现高到离谱的小费比例，我猜猜是不是周末喝高了，小手一抖，小费出手。</p><p><img src="http://upload-images.jianshu.io/upload_images/4263204-435596b9fdd8ebab.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>按吸烟习惯来看，吸烟的人出手更加随意，小费比例范围更广，而不吸烟的人出手更加谨慎。我想其中的原因可能在于吸烟者觉得自己带给了别人更多不方便，当然，也可能和吸烟者的经济状况、付费习惯有关。</p><p>将数据按性别分组，男性中的不吸烟群体的小费比例比吸烟群体要高，其中的原因可能是不吸烟的男性可能拥有更高的教育水平和经济能力。女性中的吸烟群体的小费比例明显高于不吸烟群体，中位数超过女性不吸烟群体3%左右，分布范围也更广。</p><p><img src="http://upload-images.jianshu.io/upload_images/4263204-8f2d93c3c7694312.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>从用餐时段来看，午餐的小费比例范围较窄，晚餐时段的小费比例随意性较大，这可能是由于晚餐时段用餐时长更长、餐费更高、很可能用了酒类饮料，使得小费比例较高。</p><p><strong>接下来我们再来看看小费比例和用餐人数的关系。</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#小费比例与用餐人数的关系</span><br><span class="line">tipa.groupby(&quot;size&quot;).mean()</span><br></pre></td></tr></table></figure></p><p><img src="http://upload-images.jianshu.io/upload_images/4263204-1ca44df51724db70.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>可以看到，小费比例随用餐人数的增加而降低。</p><h4 id="小费狂魔画像"><a href="#小费狂魔画像" class="headerlink" title="小费狂魔画像"></a>小费狂魔画像</h4><p>基于上述分析，我们现在可以给出一个小费狂魔的画像了。</p><p>*<em>小费狂魔：给小费比例较高的群体</em></p><blockquote><p>周六单独来餐厅吃晚餐的吸烟男性</p></blockquote><h3 id="03-结语"><a href="#03-结语" class="headerlink" title="03 结语"></a>03 结语</h3><p>今天我们通过一张餐厅用餐信息表，针对python的groupby和可视化函数进行了实操练习，给出了小费狂魔的画像。</p><p>其中涉及到数据清洗以及groupby、散点图、箱线图等方法的调用，希望对你有帮助。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/4263204-b9807e77797c67ca.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="PYTHON" scheme="http://yoursite.com/categories/PYTHON/"/>
    
    
      <category term="python" scheme="http://yoursite.com/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>Python | 泰坦尼克号幸存者画像</title>
    <link href="http://yoursite.com/2018/05/25/Python-%E6%B3%B0%E5%9D%A6%E5%B0%BC%E5%85%8B%E5%8F%B7%E5%B9%B8%E5%AD%98%E8%80%85%E7%94%BB%E5%83%8F/"/>
    <id>http://yoursite.com/2018/05/25/Python-泰坦尼克号幸存者画像/</id>
    <published>2018-05-25T07:08:06.000Z</published>
    <updated>2018-05-25T12:10:06.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://upload-images.jianshu.io/upload_images/4263204-25a03184b0f20bb3.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><a id="more"></a><h3 id="01-幸存者"><a href="#01-幸存者" class="headerlink" title="01 幸存者"></a>01 幸存者</h3><p>泰坦尼克号的沉没，是人为的悲剧，1800人罹难者近70%，让我们一起来看看泰坦尼克号的幸存者都有哪些特征吧。</p><p><strong>先给出分析框架</strong></p><blockquote><ol><li>一切的分析都建立在数据清洗之后</li><li>幸存率的分析非常重要，下面将按性别、年龄、仓位、登船码头4个维度分别观察与幸存率的关系</li><li>然后按照仓位+性别、仓位+年龄段、年龄段+性别3个二维组合维度观察与幸存率的关系</li><li>最后按仓位+性别+年龄段这个三维组合维度观察与幸存率关系</li></ol></blockquote><p>想知道在泰坦尼克号事故中活下来的人的特征么？</p><p>一起来看看吧。</p><h3 id="02-数据清洗"><a href="#02-数据清洗" class="headerlink" title="02 数据清洗"></a>02 数据清洗</h3><p>一切分析的前提，都是干净可靠的数据，所以我们先来观察一下数据情况，进行数据清洗。</p><p><strong>查看数据三步走</strong></p><blockquote><ol><li>数据大小 df.shape</li><li>字段类型及缺失值</li><li>数据头尾行</li></ol></blockquote><p>使用df.shape查看数据大小，使用df.info()查看数据字段类型和缺失值情况。</p><blockquote><ul><li>891行，12列，占据空间84kB</li><li>Age字段有20%的缺失，年龄是乘客的重要参数，后续会补全</li><li>Cabin字段有70%的缺失，船舱号码不是重要参数，考虑暂不分析该字段</li></ul></blockquote><p>df.head(), df.tail()查看数据头尾行情况</p><p><img src="https://upload-images.jianshu.io/upload_images/4263204-b482d0298071ccb7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>各字段解释如下：</p><ul><li>PassengerId: 乘客的id</li><li>Survival: 是否幸存 0 = No, 1 = Yes</li><li>Pclass: 舱位 class 1 = 1st, 2 = 2nd, 3 = 3rd</li><li>Name: 姓名</li><li>Sex: 性别</li><li>Age: 年龄</li><li>SibSp: 船上兄弟姐妹以及配偶的个数</li><li>Parch: 船上父母以及子女的个数</li><li>Ticket: 船票号码</li><li>Fare: 票价</li><li>Cabin: 船舱号码</li><li>Embarked: 登船码头 C = Cherbourg, Q = Queenstown, S = Southampton</li></ul><p><strong>补全缺失值</strong></p><p>Age字段是乘客的重要参数，需要补全。</p><p>可不能直接填充0，或者某个数去补全整个数据哦，这样做很危险，数据源会失去客观性！</p><p>那怎么办呢？考虑到不同性别的年龄层不同，不同仓位（可以理解为社会等级）的年龄层也不同，我们可以这样做：</p><blockquote><p>以性别+仓位将数据分组，用每组的中位数去补全各组的空值</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">#读取原始数据</span><br><span class="line">titanic=pd.read_csv(r&apos;D:\DataScience\python\python_course\titanic.csv&apos;,sep=&apos;;&apos;)</span><br><span class="line"></span><br><span class="line"># 分组计算不同仓位、性别的年龄中位数，得到一个Series数据，索引为Pclass、Sex</span><br><span class="line">age_median3=titanic.groupby([&quot;Pclass&quot;,&quot;Sex&quot;]).Age.median()</span><br><span class="line">titanic.set_index([&quot;Pclass&quot;,&quot;Sex&quot;],inplace=True)</span><br><span class="line"></span><br><span class="line"># 使用fillna补全空值，将根据索引进行补全</span><br><span class="line">titanic.Age.fillna(age_median3,inplace=True)</span><br><span class="line">titanic.reset_index(inplace=True)</span><br><span class="line"></span><br><span class="line">titanic.Age.describe()</span><br></pre></td></tr></table></figure><p><img src="https://upload-images.jianshu.io/upload_images/4263204-3be2b27d9ae4053c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>这样一波操作之后，Age字段有891个非空值，已经被补全。</p><h3 id="03-数据挖掘"><a href="#03-数据挖掘" class="headerlink" title="03 数据挖掘"></a>03 数据挖掘</h3><p>现在我们已经得到一分干净的数据集了，可以开动啦！</p><blockquote><p>是什么因素影响了乘客的幸存率呢？</p></blockquote><h5 id="3-1-按性别、年龄段、仓位、登船码头4个维度分别观察与幸存率的关系"><a href="#3-1-按性别、年龄段、仓位、登船码头4个维度分别观察与幸存率的关系" class="headerlink" title="3.1 按性别、年龄段、仓位、登船码头4个维度分别观察与幸存率的关系"></a>3.1 按性别、年龄段、仓位、登船码头4个维度分别观察与幸存率的关系</h5><ul><li>仓位-幸存率</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 数据透视表</span><br><span class="line">titanic.pivot_table(values=&quot;Survived&quot;,index=&quot;Pclass&quot;,aggfunc=&quot;mean&quot;)</span><br><span class="line"></span><br><span class="line">#可视化呈现</span><br><span class="line">sns.barplot(data=titanic,x=&quot;Pclass&quot;,y=&quot;Survived&quot;,ci=None)</span><br></pre></td></tr></table></figure><p><img src="https://upload-images.jianshu.io/upload_images/4263204-9c54618525ededf7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>果然，仓位等级越高，幸存率也越大，可能是由于高等仓位更远离水面，乘客也更少，有更多的逃生机会吧。</p><ul><li>性别-幸存率</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">titanic.pivot_table(values=&quot;Survived&quot;,index=&quot;Sex&quot;,aggfunc=&quot;mean&quot;)</span><br><span class="line"></span><br><span class="line">sns.barplot(data=titanic,x=&quot;Sex&quot;,y=&quot;Survived&quot;,ci=None)</span><br></pre></td></tr></table></figure><p><img src="https://upload-images.jianshu.io/upload_images/4263204-ee2774608813bf7e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>女性幸存率明显高于男性，绅士风度在死亡面前依然存在，让人感动。</p><ul><li>年龄段-幸存率</li></ul><p>Age字段是一个连续变量而不是分类变量，我们需要将Age字段离散化之后再进行分析。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 连续变量离散化：将某个变量的所在区间分割为几个小区间，落在同一个区间的观测值用同一个符号表示</span><br><span class="line">titanic[&quot;Ageband&quot;]=pd.cut(titanic[&quot;Age&quot;],5)</span><br></pre></td></tr></table></figure><p>现在我们给titanic这个dataframe新增了一列“Ageband”，它代表Age字段所在的年龄段</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># 可视化</span><br><span class="line">sns.barplot(data=titanic,x=&quot;Ageband&quot;,y=&quot;Survived&quot;,ci=None)</span><br><span class="line">plt.xticks(rotation=60)</span><br></pre></td></tr></table></figure><p><img src="https://upload-images.jianshu.io/upload_images/4263204-2bacce691b00ff1e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>低年龄段生存率最高，64岁以上老人生存率最低，青壮年次之，看来大家还是很有爱的——小朋友先救，青壮年让位，老人可能体力不支或自动放弃。</p><ul><li>登船码头-幸存率<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 用groupby也可实现数据透视表</span><br><span class="line">titanic[[&quot;Embarked&quot;,&quot;Survived&quot;]].groupby(&quot;Embarked&quot;).mean()</span><br><span class="line"></span><br><span class="line">sns.barplot(data=titanic,x=&quot;Embarked&quot;,y=&quot;Survived&quot;,ci=None)</span><br></pre></td></tr></table></figure></li></ul><p><img src="https://upload-images.jianshu.io/upload_images/4263204-2dd0f82bb3d2f94e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>C码头登船的幸存率最高，为什么呢？我们来看看各码头登船乘客的仓位情况</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 数据透视表</span><br><span class="line">titanic.pivot_table(values=&quot;Name&quot;,index=&quot;Pclass&quot;,columns=&quot;Embarked&quot;,aggfunc=&quot;count&quot;)</span><br></pre></td></tr></table></figure><p><img src="https://upload-images.jianshu.io/upload_images/4263204-731c4b7bd13ef82a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><ul><li>S码头登船人数最多，大部分是3等仓位</li><li>Q码头登船的人90%以上是3等仓位</li><li>C码头登船的人半数是1等仓位，数据来看1等仓位的幸存率较高，因此C码头登船的人幸存率较高可解释</li><li>看来C码头主要是有钱人登船，S码头就主要是穷人了</li></ul><h5 id="3-2-按照仓位-性别、仓位-年龄段、年龄段-性别观察与幸存率的关系"><a href="#3-2-按照仓位-性别、仓位-年龄段、年龄段-性别观察与幸存率的关系" class="headerlink" title="3.2 按照仓位+性别、仓位+年龄段、年龄段+性别观察与幸存率的关系"></a>3.2 按照仓位+性别、仓位+年龄段、年龄段+性别观察与幸存率的关系</h5><ul><li>仓位+性别-幸存率<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 数据透视表走起，以数字形式观察结果</span><br><span class="line">titanic.pivot_table(values=&quot;Survived&quot;,index=&quot;Pclass&quot;,columns=&quot;Sex&quot;,aggfunc=&quot;mean&quot;)</span><br><span class="line"></span><br><span class="line"># seaborn作图走起，以图像形式观察结果</span><br><span class="line">sns.barplot(data=titanic,x=&quot;Pclass&quot;,y=&quot;Survived&quot;,hue=&quot;Sex&quot;,ci=None)</span><br></pre></td></tr></table></figure></li></ul><p><img src="https://upload-images.jianshu.io/upload_images/4263204-ef5c48b267a9f0ba.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>男性幸存率普遍低于女性，这难道是传说中的绅士风度在起作用？</p><p>高等仓位幸存率高于低等仓位，一方面可能是因为高等仓位在上层，淹水较慢，逃生时间够长，另一方面可能是人为因素，高等仓位更受照顾；</p><p>一二等仓的女性幸存率很高啊，二三等仓的男性幸存率极低。</p><ul><li>仓位+年龄段-幸存率<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sns.pointplot(data=titanic,x=&quot;Ageband&quot;,y=&quot;Survived&quot;,hue=&quot;Pclass&quot;,ci=None)</span><br><span class="line">plt.xticks(rotation=60)</span><br></pre></td></tr></table></figure></li></ul><p><img src="https://upload-images.jianshu.io/upload_images/4263204-b63561310d1a3c4c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>各年龄段1等仓位的生存率最高，3等仓位生存率最低；</p><p>低年龄段的生存率逐次高于高年龄段；</p><p>在考虑各分组生存率的同时，要考虑各分组人数，比如该分组并没有人，那么生存率自然是0，但我们并不能说该分组生存率最低。</p><ul><li>性别+年龄段-幸存率<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">titanic.pivot_table(values=&quot;Survived&quot;,index=&quot;Ageband&quot;,columns=&quot;Sex&quot;,aggfunc=&quot;mean&quot;)</span><br><span class="line"></span><br><span class="line">sns.barplot(data=titanic,x=&quot;Ageband&quot;,y=&quot;Survived&quot;,hue=&quot;Sex&quot;,ci=None)</span><br><span class="line"></span><br><span class="line"># 设置横轴标签位置</span><br><span class="line">plt.xticks(rotation=60)</span><br></pre></td></tr></table></figure></li></ul><p><img src="https://upload-images.jianshu.io/upload_images/4263204-3e4d9efe6c147700.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>男性生存率明显偏低与女性，女性高年龄段的生存率逐次高于低年龄段的。</p><h5 id="3-3-三维分析"><a href="#3-3-三维分析" class="headerlink" title="3.3 三维分析"></a>3.3 三维分析</h5><p>前面的分析从一维、二维角度分析了因素与幸存率的关系，下面我们直接从三维因素来分析。</p><ul><li>年龄段+性别+仓位</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">titanic.pivot_table(values=&quot;Survived&quot;,index=&quot;Ageband&quot;,columns=[&quot;Sex&quot;,&quot;Pclass&quot;],aggfunc=&quot;mean&quot;)</span><br></pre></td></tr></table></figure><p><img src="https://upload-images.jianshu.io/upload_images/4263204-bf80415d517e1238.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>输出结果展示了各年龄段下，各性别分别在123等仓位的幸存率。这张表各可能会让你晕晕的，那么我们就可视化呈现吧。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&quot;&quot;&quot;各性别下，仓位+年龄段与幸存率关系&quot;&quot;&quot;</span><br><span class="line"></span><br><span class="line"># aspect设置画布长宽比</span><br><span class="line"># palette设置hue分组的颜色</span><br><span class="line">sns.FacetGrid(data=titanic,row=&quot;Sex&quot;,aspect=1.5)\</span><br><span class="line">.map(sns.pointplot,&quot;Ageband&quot;,&quot;Survived&quot;,&quot;Pclass&quot;,palette=&quot;deep&quot;,ci=None)\</span><br><span class="line">.add_legend()</span><br><span class="line"></span><br><span class="line">plt.xticks(rotation=60)</span><br></pre></td></tr></table></figure></p><p><img src="https://upload-images.jianshu.io/upload_images/4263204-01c49f1f489ad893.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>男性低年龄段幸存率最高，高等仓位幸存率更高；</p><p>中老年女性幸存率最高，1、2等仓位的女性幸存率几乎达到100%，3等仓位女性比较惨一点。</p><ul><li>仓位+登船码头+性别<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 直接可视化呈现吧</span><br><span class="line">sns.FacetGrid(data=titanic,col=&quot;Pclass&quot;,row=&quot;Embarked&quot;)\</span><br><span class="line">.map(sns.barplot,&quot;Pclass&quot;,&quot;Survived&quot;,&quot;Sex&quot;,hue_order=[&quot;male&quot;,&quot;female&quot;],palette=&quot;deep&quot;,ci=None)\</span><br><span class="line">.add_legend()</span><br></pre></td></tr></table></figure></li></ul><p><img src="https://upload-images.jianshu.io/upload_images/4263204-813fd22b56c7c027.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>不论从登船码头还是仓位来看，女性幸存率普遍高于男性；</p><p>按性别来看，高等仓位幸存率高于低等仓位；</p><p><strong>Q码头登船的男乘客生存率最低，我们来看看是不是Q码头男乘客数量较少？</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">titanic.pivot_table(values=&quot;Survived&quot;,index=&quot;Embarked&quot;,columns=&quot;Sex&quot;,aggfunc=&quot;count&quot;)</span><br></pre></td></tr></table></figure><p><img src="https://upload-images.jianshu.io/upload_images/4263204-fd47b7807db25f47.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>Q码头登船男乘客多于女乘客，但几乎都罹难了，为什么呢？我们来看看男乘客的仓位、年龄段分布情况，是不是这些情况导致了男乘客生存率较低.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">titanic.pivot_table(values=&quot;Survived&quot;,index=[&quot;Embarked&quot;,&quot;Pclass&quot;],columns=[&quot;Sex&quot;,&quot;Ageband&quot;],aggfunc=&quot;count&quot;)</span><br></pre></td></tr></table></figure><p><img src="https://upload-images.jianshu.io/upload_images/4263204-6a03ebdf2a5fb3aa.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>Q码头登船的男乘客，绝大部分处于16-32岁，3等仓位，这个分段的乘客幸存率是最低的，解释了为什么Q码头登船的男乘客幸存率趋于0的现象。</p><h3 id="04-预告"><a href="#04-预告" class="headerlink" title="04 预告"></a>04 预告</h3><p>本次针对泰坦尼克号乘客数据，我们分析了幸存者的特征画像：</p><blockquote><p>女性，儿童，头等舱，绅士风度</p></blockquote><p>本次未对数据的直系、旁系亲属个数进行分析，下期考虑加入。</p><p>本次主要使用了数据透视表和seaborn包绘图呈现结果，下期考虑加入特征工程对数据进一步分析。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/4263204-25a03184b0f20bb3.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="PYTHON" scheme="http://yoursite.com/categories/PYTHON/"/>
    
    
      <category term="python" scheme="http://yoursite.com/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>Python | 共享单车需求分析</title>
    <link href="http://yoursite.com/2018/05/25/Python-%E5%85%B1%E4%BA%AB%E5%8D%95%E8%BD%A6%E9%9C%80%E6%B1%82%E5%88%86%E6%9E%90/"/>
    <id>http://yoursite.com/2018/05/25/Python-共享单车需求分析/</id>
    <published>2018-05-25T07:07:35.000Z</published>
    <updated>2018-05-25T12:09:30.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://upload-images.jianshu.io/upload_images/4263204-08aab9242cc99053.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><a id="more"></a><h3 id="01-目的"><a href="#01-目的" class="headerlink" title="01 目的"></a>01 目的</h3><p>手里有一份A市近两年来共享单车的租车数据，字段丰富，可挖掘的东西蛮多的，真是让人蠢蠢欲动~~</p><p>那么今天我们就来挖一挖这份数据，看看是<strong>哪些因素影响着人们的租车需求。</strong></p><p>先给出数据各字段以及含义，先思考一下，如果是你，你会如何分析？</p><p><img src="https://upload-images.jianshu.io/upload_images/4263204-a542744825c76083.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><h3 id="02-数据清洗"><a href="#02-数据清洗" class="headerlink" title="02 数据清洗"></a>02 数据清洗</h3><p>拿到任何数据，第一件事是思考数据价值，思考你分析这份数据的目的，然后呢。</p><p>当然是数据的观察和清洗，不干净的数据分析出来的结果你信么？</p><blockquote><p>老套路，数据观察3步走：</p><ol><li>数据大小 (df.shape)</li><li>各字段数据类型、缺失值 (df.info)</li><li>head、tail数据 (df.head)</li></ol></blockquote><p><img src="https://upload-images.jianshu.io/upload_images/4263204-b5ec04fbe65cc426.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>可以看到，数据共10886行，12列，各字段均无缺失值（真是棒棒哒数据集呐）</p><p>再来看看数据表结构</p><p><img src="https://upload-images.jianshu.io/upload_images/4263204-1c142c98584dfdbf.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>可以看到， datetime字段是日期格式，可以进一步处理得到年月日时间周几等信息；气温、体表温度、湿度、风速字段是连续变量，需要离散化处理后分析。</p><h3 id="03-数据处理"><a href="#03-数据处理" class="headerlink" title="03 数据处理"></a>03 数据处理</h3><p>刚才提到，datetime字段可以进一步处理，得到年、月、日、时、周几等信息，从而进一步结合时间信息来分析A市共享单车需求。</p><p><strong>下面我们针对日期型变量进行处理。</strong></p><p>主要思路：分裂split，切片</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 自定义函数获取日期</span><br><span class="line">def get_date(x):</span><br><span class="line">    return x.split()[0]</span><br><span class="line"># 对指定字段应用自定义函数apply()</span><br><span class="line">BikeData[&quot;date&quot;]=BikeData.datetime.apply(get_date)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># 自定义函数获取时间</span><br><span class="line">def get_hour(x):</span><br><span class="line">    hour=x.split()[1].split(&quot;:&quot;)[0]</span><br><span class="line">    int_hour=int(hour) # 注意，这里的hour要转换为数值型，因为字符串型在排序时不按数值型排序规则来</span><br><span class="line">    return int_hour</span><br><span class="line"></span><br><span class="line">BikeData[&quot;hour&quot;]=BikeData.datetime.apply(get_hour)</span><br></pre></td></tr></table></figure><p>接下来我们想得到日期对应的星期数，思路是将字符串格式的日期通过datetime包中的strptime函数转换为日期时间类型，然后通过.weekday获取对应的星期数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">def get_weekday(x):</span><br><span class="line">    dateStr=x.split()[0]</span><br><span class="line">    dateDT=datetime.strptime(dateStr,&quot;%Y/%m/%d&quot;)</span><br><span class="line">    week_day=dateDT.weekday()</span><br><span class="line">    return week_day</span><br><span class="line"></span><br><span class="line">BikeData[&quot;weekday&quot;]=BikeData.datetime.apply(get_weekday)</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># 同样的，自定义函数获取日期对应的月份</span><br><span class="line"># 这里也可以使用切片+split的方法得到月份  x.split()[0].split(&quot;/&quot;)[1]</span><br><span class="line">def get_month(x):</span><br><span class="line">    dateStr=x.split()[0]</span><br><span class="line">    dateDT=datetime.strptime(dateStr,&quot;%Y/%m/%d&quot;)</span><br><span class="line">    month=dateDT.month</span><br><span class="line">    return month</span><br><span class="line"></span><br><span class="line">BikeData[&quot;month&quot;]=BikeData.datetime.apply(get_month)</span><br></pre></td></tr></table></figure><p>好了，到这里，日期型变量处理完毕，现在的数据表结构是这样的，我们可以正式开始挖掘分析了。</p><p><img src="https://upload-images.jianshu.io/upload_images/4263204-f2e5ce0c93d85353.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><h3 id="04-数据挖掘"><a href="#04-数据挖掘" class="headerlink" title="04 数据挖掘"></a>04 数据挖掘</h3><h5 id="4-1-相关性分析"><a href="#4-1-相关性分析" class="headerlink" title="4.1 相关性分析"></a>4.1 相关性分析</h5><p>我们先来看一看各字段之间的相关性，其中：</p><ul><li>相关系数介于-1,1之间</li><li>负数表示负相关，正数表示正相关</li><li>绝对值越大，关系越强</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># df.corr()计算dataframe中各字段的相关系数</span><br><span class="line">correlation=BikeData[[&quot;season&quot;,&quot;holiday&quot;,&quot;workingday&quot;,&quot;weather&quot;,&quot;temp&quot;,&quot;atemp&quot;,&quot;humidity&quot;,&quot;windspeed&quot;,&quot;casual&quot;,&quot;registered&quot;,&quot;count&quot;]].corr()</span><br></pre></td></tr></table></figure><p><img src="https://upload-images.jianshu.io/upload_images/4263204-0cedf34606e85b51.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>好像有点让人眼花缭乱，那么我们就用热地图可视化相关系数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">fig=plt.figure(figsize=(12,12))</span><br><span class="line"># 使用热地图(heat map)更直观地展示系数矩阵情况</span><br><span class="line"># vmax设定热地图色块的最大区分值</span><br><span class="line"># square设定图片为正方形与否</span><br><span class="line"># annot设定是否显示每个色块的系数值</span><br><span class="line">sns.heatmap(correlation,vmax=1,square=True,annot=True)</span><br></pre></td></tr></table></figure><p><img src="https://upload-images.jianshu.io/upload_images/4263204-91720540ef182096.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p><strong>可以看到，</strong></p><ul><li>count（租车人数）：温度、体感温度与租车人数正相关-寒冷抑制租车需求；湿度与人数负相关-雨雪天气抑制租车需求；注册人数、非注册人数与租车人数强正相关-转化率问题，用户越多，租车需求越多；</li><li>registered（注册用户数）：温度高、工作日，刺激民众成为注册用户-租车的需求可能更多的是非寒冷天气的通勤；非注册用户与注册用户数强正相关-先试用再转化，是一种商业模式；</li><li>temp（气温）：气温和体温强正相关-当然气温越高体温越高</li><li>season（季节）：春季更干燥、低温</li></ul><h5 id="4-2-可视化分析"><a href="#4-2-可视化分析" class="headerlink" title="4.2 可视化分析"></a>4.2 可视化分析</h5><p>接下来我们通过可视化来观察租车需求的相关因素。</p><h6 id="4-2-1-租车人数在各分类变量下的箱线图"><a href="#4-2-1-租车人数在各分类变量下的箱线图" class="headerlink" title="4.2.1 租车人数在各分类变量下的箱线图"></a>4.2.1 租车人数在各分类变量下的箱线图</h6><ul><li>租车人数箱线图（小时为单位）</li><li>各月份租车人数箱线图</li><li>各星期数租车人数箱线图</li><li>各小时（0~23时）租车人数箱线图</li><li>各季节租车人数箱线图</li><li>各天气租车人数箱线图</li><li>节假日与否的租车人数箱线图</li><li>周末与否的租车人数箱线图</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"># 绘制多图</span><br><span class="line">plt.style.use(&quot;ggplot&quot;)</span><br><span class="line">fig=plt.figure(figsize=(16,24))</span><br><span class="line"></span><br><span class="line"># 设置图像大标题</span><br><span class="line">fig.suptitle(&quot;ShareBike Analysis&quot;,fontsize=16,fontweight=&quot;bold&quot;)</span><br><span class="line"></span><br><span class="line"># 添加第一个子图</span><br><span class="line">ax1=fig.add_subplot(4,2,1)</span><br><span class="line">sns.boxplot(data=BikeData,y=&quot;count&quot;)</span><br><span class="line">plt.title(&quot;box plot on count&quot;)</span><br><span class="line">plt.ylabel(&quot;Count&quot;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 添加第二个子图</span><br><span class="line">ax2=fig.add_subplot(4,2,2)</span><br><span class="line">sns.boxplot(data=BikeData,x=&quot;month&quot;,y=&quot;count&quot;,hue=&quot;workingday&quot;)</span><br><span class="line">ax2.set(ylabel=&quot;Count&quot;,xlabel=&quot;Month&quot;,title=&quot;box plot on count across month&quot;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 添加第三个子图</span><br><span class="line">ax3=fig.add_subplot(4,2,3)</span><br><span class="line">sns.boxplot(data=BikeData,x=&quot;weekday&quot;,y=&quot;count&quot;)</span><br><span class="line">ax3.set(ylabel=&quot;Count&quot;,xlabel=&quot;Weekday&quot;,title=&quot;box plot on count across weekday&quot;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 添加第四个子图</span><br><span class="line">ax4=fig.add_subplot(4,2,4)</span><br><span class="line">sns.boxplot(data=BikeData,x=&quot;hour&quot;,y=&apos;count&apos;)</span><br><span class="line"></span><br><span class="line"># 下面两句代码与ax2.set()效果一样</span><br><span class="line"># plt.title(&quot;box plot on count&quot;)</span><br><span class="line"># plt.ylabel(&quot;Count&quot;)</span><br><span class="line">ax4.set(ylabel=&quot;Count&quot;,xlabel=&quot;Hour&quot;,title=&quot;box plot on count aross hours&quot;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 添加第五个子图</span><br><span class="line">ax5=fig.add_subplot(4,2,5)</span><br><span class="line">sns.boxplot(data=BikeData,x=&quot;season&quot;,y=&quot;count&quot;,hue=&quot;weather&quot;)</span><br><span class="line">ax5.set(ylabel=&quot;Count&quot;,xlabel=&quot;Season&quot;,title=&quot;box plot on count across season&quot;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 添加第六个子图</span><br><span class="line">ax6=fig.add_subplot(4,2,6)</span><br><span class="line">sns.boxplot(data=BikeData,x=&quot;weather&quot;,y=&quot;count&quot;)</span><br><span class="line">ax6.set(ylabel=&quot;Count&quot;,xlabel=&quot;Weather&quot;,title=&quot;box plot on count across weather&quot;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 添加第七个子图</span><br><span class="line">ax7=fig.add_subplot(4,2,7)</span><br><span class="line">sns.boxplot(data=BikeData,x=&quot;holiday&quot;,y=&quot;count&quot;)</span><br><span class="line">ax7.set(ylabel=&quot;Count&quot;,xlabel=&quot;Holiday&quot;,title=&quot;box plot on count across holiday&quot;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 添加第八个子图</span><br><span class="line">ax8=fig.add_subplot(4,2,8)</span><br><span class="line">sns.boxplot(data=BikeData,x=&quot;workingday&quot;,y=&quot;count&quot;)</span><br><span class="line">ax8.set(ylabel=&quot;Count&quot;,xlabel=&quot;Workingday&quot;,title=&quot;box plot on count across workingday&quot;)</span><br></pre></td></tr></table></figure><p><img src="https://upload-images.jianshu.io/upload_images/4263204-22b81a811d34044b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p><strong>可以看到，</strong></p><ul><li>每小时的租车人数中位数在150上下；</li><li>寒冷季节（1,2,12月），工作日租车人数高于非工作日，看来寒冷季节租车以通勤为主，那么冷的天，周末当然是窝在家里啦；温暖、凉爽季节（5-11月），非工作日租车人数高于工作日，看来这些季节租车以游玩为主，春暖花开、夏日蝉鸣、秋高气爽，当然要骑车车出去玩耍啦；</li><li>租车高峰时段为早上的7、8、9点和下午的5、6、7点，正好是上下班高峰期；</li><li>春季租车人数少，可能是乍暖还寒，人们不愿意出门，并且这段时间正好赶上中国春节，大城市人口外流，租车需求减少；</li><li>天气越好，租车的人越多，暴雨暴雪一般没有人租车</li></ul><h6 id="4-2-2-连续变量与租车人数的关系"><a href="#4-2-2-连续变量与租车人数的关系" class="headerlink" title="4.2.2 连续变量与租车人数的关系"></a>4.2.2 连续变量与租车人数的关系</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 连续变量离散化，使用pd.cut分为5段</span><br><span class="line">BikeData[&quot;temp_band&quot;]=pd.cut(BikeData[&quot;temp&quot;],4)</span><br><span class="line">BikeData[&quot;humidity_band&quot;]=pd.cut(BikeData[&quot;humidity&quot;],5)</span><br><span class="line">BikeData[&quot;windspeed_band&quot;]=pd.cut(BikeData[&quot;windspeed&quot;],5)</span><br></pre></td></tr></table></figure><p>连续变量离散化后，我们来看看气温、湿度、天气对租车人数的影响吧</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># 将季节1234对应到春夏秋冬（使用映射函数.map）</span><br><span class="line">BikeData[&quot;season_word&quot;]=BikeData[&quot;season&quot;].map(&#123;1:&quot;Spring&quot;,2:&quot;Summer&quot;,3:&quot;Autumn&quot;,4:&quot;Winter&quot;&#125;)</span><br><span class="line"></span><br><span class="line">sns.FacetGrid(data=BikeData,row=&quot;humidity_band&quot;,aspect=2.2).\</span><br><span class="line">map(sns.barplot,&quot;temp_band&quot;,&quot;count&quot;,&quot;season_word&quot;,hue_order=[&quot;Spring&quot;,&quot;Summer&quot;,&quot;Autumn&quot;,&quot;Winter&quot;],palette=&quot;deep&quot;,ci=None).\</span><br><span class="line">add_legend()</span><br><span class="line">plt.xticks(rotation=60)</span><br></pre></td></tr></table></figure><p><img src="https://upload-images.jianshu.io/upload_images/4263204-d68b3bef8f5ff9f8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p><strong>可以看到，</strong></p><ul><li>气温低于10，高于30度，租车人数较少-太冷太热都会抑制租车需求</li><li>空气湿度越高，租车人数越少-干爽的天气骑车比较舒适</li><li>干燥的夏天、湿润的冬天，秋天是租车需求比较旺盛的时期</li></ul><h6 id="4-2-3-不同季节下，各小时段的租车人数情况"><a href="#4-2-3-不同季节下，各小时段的租车人数情况" class="headerlink" title="4.2.3 不同季节下，各小时段的租车人数情况"></a>4.2.3 不同季节下，各小时段的租车人数情况</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">plt.style.use(&quot;ggplot&quot;)</span><br><span class="line"></span><br><span class="line">sns.FacetGrid(data=BikeData,size=6,aspect=1.5).\</span><br><span class="line">map(sns.pointplot,&quot;hour&quot;,&quot;count&quot;,&quot;season_word&quot;,hue_order=[&quot;Spring&quot;,&quot;Summer&quot;,&quot;Autumn&quot;,&quot;Winter&quot;],paletter=&quot;deep&quot;,ci=None).\</span><br><span class="line">add_legend()</span><br></pre></td></tr></table></figure><p><img src="https://upload-images.jianshu.io/upload_images/4263204-fac8790f0164ff25.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p><strong>可以看到，</strong></p><ul><li>不论季节，每天早晨7-9点，傍晚16-19点是租车高峰期，分别在8点和17点达到时段峰值</li><li>工作时段的租车人数处于一天中的中间水平，夜幕降临后，租车人数逐渐减少-夜晚寒冷、阴暗，骑车不便利</li><li>春季用车人数总体较少，夏秋季最多</li></ul><h6 id="4-2-4-工作日与否，各小时租车人数情况"><a href="#4-2-4-工作日与否，各小时租车人数情况" class="headerlink" title="4.2.4 工作日与否，各小时租车人数情况"></a>4.2.4 工作日与否，各小时租车人数情况</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sns.FacetGrid(data=BikeData,size=6,aspect=1.5).\</span><br><span class="line">map(sns.pointplot,&quot;hour&quot;,&quot;count&quot;,&quot;workingday&quot;,hue_order=[1,0],paletter=&quot;deep&quot;,ci=None).\</span><br><span class="line">add_legend()</span><br></pre></td></tr></table></figure><p><img src="https://upload-images.jianshu.io/upload_images/4263204-546d6fce06269111.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p><strong>可以看到，</strong></p><ul><li>是否是工作日，对于用车高峰时段的影响非常大</li><li>工作日的租车高峰时段非常明显，处于7-9点，16-19点-通勤为主</li><li>非工作日租车高峰时段特征较为平缓，从上午10点租车人数逐渐增多，到晚上8点后，租车人数回到低峰水平-非工作日主要用于休闲代步、短途旅游等（大家起床都很迟嘛）</li></ul><h6 id="4-2-5-不同天气情况下，各月份的租车人数"><a href="#4-2-5-不同天气情况下，各月份的租车人数" class="headerlink" title="4.2.5 不同天气情况下，各月份的租车人数"></a>4.2.5 不同天气情况下，各月份的租车人数</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">BikeData[&quot;weather_word&quot;]=BikeData[&quot;weather&quot;].map(&#123;1:&quot;sunny&quot;,2:&quot;foggy&quot;,3:&quot;rainy&quot;,4:&quot;stormy&quot;&#125;)</span><br><span class="line"></span><br><span class="line"># 数据透视表呈现</span><br><span class="line">BikeData[[&quot;count&quot;,&quot;month&quot;,&quot;weather_word&quot;]].pivot_table(values=&quot;count&quot;,index=&quot;month&quot;,columns=&quot;weather_word&quot;,aggfunc=&quot;mean&quot;)</span><br><span class="line"></span><br><span class="line"># 可视化呈现</span><br><span class="line">sns.FacetGrid(data=BikeData,size=6,aspect=1.5).\</span><br><span class="line">map(sns.pointplot,&quot;month&quot;,&quot;count&quot;,&quot;weather_word&quot;,hue_order=[&quot;sunny&quot;,&quot;foggy&quot;,&quot;rainy&quot;,&quot;stromy&quot;],paletter=&quot;deep&quot;,ci=None).\</span><br><span class="line">add_legend()</span><br></pre></td></tr></table></figure><p><img src="https://upload-images.jianshu.io/upload_images/4263204-bb5357d7358585a9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p><strong>可以看到，</strong></p><ul><li>天气越好，租车人数越多</li><li>5-10月租车人数最多-与天气、气候、营销宣传都有关系</li></ul><h3 id="05-预告"><a href="#05-预告" class="headerlink" title="05 预告"></a>05 预告</h3><p>今天我们针对一份上万行的共享单车数据进行挖掘分析，我们做了相关性分析以及可视化分析，知道了是哪些因素在影响A市的租车需求。</p><p>这份数据还有很多地方可以挖掘，比如预测某个特定条件下的租车人数。</p><p>这就需要结合机器学习的方法，让机器自己去拟合最佳的权重系数，这是我们后面将要研究的主要课题。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/4263204-08aab9242cc99053.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="PYTHON" scheme="http://yoursite.com/categories/PYTHON/"/>
    
    
      <category term="python" scheme="http://yoursite.com/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>python | 销售记录可视化</title>
    <link href="http://yoursite.com/2018/05/25/python-%E9%94%80%E5%94%AE%E8%AE%B0%E5%BD%95%E5%8F%AF%E8%A7%86%E5%8C%96/"/>
    <id>http://yoursite.com/2018/05/25/python-销售记录可视化/</id>
    <published>2018-05-25T07:06:27.000Z</published>
    <updated>2018-05-25T12:10:14.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://upload-images.jianshu.io/upload_images/4263204-d4464235e1e3f36c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><a id="more"></a><h3 id="01-内容提要"><a href="#01-内容提要" class="headerlink" title="01 内容提要"></a>01 内容提要</h3><p>本周我们利用python的matplotlib，针对性地练习数据可视化技能。</p><p>我们拿到一家公司的销售记录，共有1500条销售数据，现在我们对这张销售记录进行可视化分析吧，这是数据分析师的必经之路哦。</p><blockquote><p>内容提要：</p><ul><li>条形图：各公司交易额</li><li>多图：各公司交易额、订单数<ul><li>饼图：各公司交易额占比TOP10总额</li><li>散点图：各公司订单数-交易额分布</li><li>直方图：单笔订单交易额分布情况</li></ul></li></ul></blockquote><p>那么我们开始吧！</p><h3 id="02-数据处理"><a href="#02-数据处理" class="headerlink" title="02 数据处理"></a>02 数据处理</h3><p>首先使用pd.read_excel读取数据，定义该数据表名为df，数据结构如下，这组数据记录了某公司2014年的交易情况：</p><ul><li>account number: 账号</li><li>name: 公司名字，与账号有一一对应关系</li><li>sku: 商品货号</li><li>quantity: 购货量</li><li>unit price: 单位价格</li><li>ext price: 总价 = 购货量*单位价格</li><li>date: 日期</li></ul><p><img src="https://upload-images.jianshu.io/upload_images/4263204-5a311a17fd2d585c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>通过df.info()查看各字段总数，可以看到共有1500条数据。</p><h5 id="数据清洗"><a href="#数据清洗" class="headerlink" title="数据清洗"></a>数据清洗</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#查看数据时发现，购货量有负数，将这些记录筛选出来，根据实际情况决定是否归为异常数据</span><br><span class="line">df[df.quantity&lt;0]</span><br><span class="line">#由于不了解实际情况，目前暂时认为购货量负数为正常值（可从公司名name统计，看看是否是某几个公司出现的情况，是否是退货）</span><br></pre></td></tr></table></figure><h5 id="统计有交易记录的公司数量"><a href="#统计有交易记录的公司数量" class="headerlink" title="统计有交易记录的公司数量"></a>统计有交易记录的公司数量</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">len(df.name.unique()) #与之交易的公司数量，20个</span><br></pre></td></tr></table></figure><h5 id="筛选出交易额最高的10家公司"><a href="#筛选出交易额最高的10家公司" class="headerlink" title="筛选出交易额最高的10家公司"></a>筛选出交易额最高的10家公司</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#将df按公司名name分组，对各组交易额ext price求和得到各公司总交易额，计数得到各公司总订单数</span><br><span class="line">#为了不将name作为索引，使用reset_index重置索引</span><br><span class="line">#使用sort_values()对指定列排序</span><br><span class="line">top10=df.groupby(&apos;name&apos;)[&apos;ext price&apos;].agg([&apos;sum&apos;,&apos;count&apos;]).reset_index().sort_values(by=&apos;sum&apos;,ascending=False)[:10]</span><br><span class="line">top10.rename(columns=&#123;&apos;name&apos;:&apos;Company&apos;,&apos;sum&apos;:&apos;Sales&apos;,&apos;count&apos;:&apos;Purchases&apos;&#125;,inplace=True)</span><br><span class="line">top10</span><br></pre></td></tr></table></figure><p>得到如下数据表，下面我们将基于此表进行数据的可视化，展现交易额top10的公司情况。</p><p><img src="https://upload-images.jianshu.io/upload_images/4263204-714ab153b8912be9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><h3 id="03-数据可视化"><a href="#03-数据可视化" class="headerlink" title="03 数据可视化"></a>03 数据可视化</h3><h5 id="条形图"><a href="#条形图" class="headerlink" title="条形图"></a>条形图</h5><p>查看top10公司交易额情况<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">#使用ggplot风格的作图：</span><br><span class="line">plt.style.use(&apos;ggplot&apos;)</span><br><span class="line"></span><br><span class="line">#barh绘制水平条形图；bar绘制垂直直方图</span><br><span class="line">&quot;&quot;&quot;注意，条形图条数np.arange(10),要与top10.Sales数据数量一致，否则会报错-形状不匹(shape mismatch)&quot;&quot;&quot;</span><br><span class="line">plt.barh(np.arange(10),top10.Sales,height=0.6)</span><br><span class="line"></span><br><span class="line">#添加标题</span><br><span class="line">plt.title(&apos;Top 10 Sales Company&apos;)</span><br><span class="line">plt.xlabel(&apos;Total Revenue&apos;)</span><br><span class="line">plt.ylabel(&apos;Company&apos;)</span><br><span class="line"></span><br><span class="line">#修改纵坐标、横坐标刻度</span><br><span class="line">plt.yticks(np.arange(10),top10.Company)</span><br><span class="line">plt.xticks([0,20000,40000,60000,80000,100000,120000,140000],</span><br><span class="line">          [&apos;$0k&apos;,&apos;$20k&apos;,&apos;$40k&apos;,&apos;$60k&apos;,&apos;$80k&apos;,&apos;$100k&apos;,&apos;$120k&apos;,&apos;$140k&apos;])</span><br><span class="line"></span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure></p><p>输出如下</p><p><img src="https://upload-images.jianshu.io/upload_images/4263204-8caa1d4eb57f2d16.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p><strong>浅析</strong></p><ul><li>可以看到，交易额最高的公司是Kulas Inc和White-Trantow公司，达到了近14万美元。</li><li>接下来可以从这两家公司订购的商品种类、以及各种类商品采购量入手，分析高交易额的原因，公司偏好-高交易额是因为买的种类多还是某类商品订购量大，同理可分析其他公司</li><li>从订单数计算单笔订单交易额，分析客户订购偏好-大批量采购/少量订购</li></ul><h5 id="绘制多图"><a href="#绘制多图" class="headerlink" title="绘制多图"></a>绘制多图</h5><p>将多个图展现在同一画布中，便于进一步分析，以下仅做示例。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">plt.style.use(&apos;ggplot&apos;)</span><br><span class="line">#设置画布大小</span><br><span class="line">fig=plt.figure(figsize=(10,10))</span><br><span class="line"></span><br><span class="line">#加上图像大标题</span><br><span class="line">fig.suptitle(&apos;Sales Analysis&apos;,fontsize=16,fontweight=&apos;bold&apos;)</span><br><span class="line"></span><br><span class="line">#fig.add_subplot(x,y,z),表示将画布分为x行,y列,当前图像放在从左到右、从上到下的第z个位置</span><br><span class="line"></span><br><span class="line">#添加第一个子图</span><br><span class="line">ax1=fig.add_subplot(2,2,1)</span><br><span class="line">plt.barh(np.arange(10),top10.Sales,height=0.5,tick_label=top10.Company)</span><br><span class="line">plt.title(&apos;Revenue&apos;)</span><br><span class="line"></span><br><span class="line">#加入平均销售额线  plt.axvline()表示添加垂直线axis vertical line</span><br><span class="line">revenue_avg=top10.Sales.mean()</span><br><span class="line">plt.axvline(x=revenue_avg,color=&apos;b&apos;,linestyle=&apos;--&apos;,linewidth=3)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#添加第二个子图</span><br><span class="line">ax2=fig.add_subplot(222)</span><br><span class="line">plt.barh(np.arange(10),top10.Purchases,height=0.5)</span><br><span class="line">plt.title(&apos;Purchases&apos;)</span><br><span class="line"></span><br><span class="line">#设置不显示y轴刻度</span><br><span class="line">plt.yticks(visible=False)</span><br><span class="line"></span><br><span class="line">#加入平均订单数线</span><br><span class="line">Purchases_avg=top10.Purchases.mean()</span><br><span class="line">plt.axvline(x=Purchases_avg,color=&apos;b&apos;,linestyle=&apos;--&apos;,linewidth=3)</span><br></pre></td></tr></table></figure><p>输出如下</p><p><img src="https://upload-images.jianshu.io/upload_images/4263204-97779e6e08b18f92.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><h5 id="饼图"><a href="#饼图" class="headerlink" title="饼图"></a>饼图</h5><p>top10公司销售额占比<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">#plt.pie()绘制饼图</span><br><span class="line">labels代表每个扇区的标签，</span><br><span class="line">colors=[&apos;b&apos;,&apos;g&apos;],设置扇区颜色</span><br><span class="line">startangle代表起始位置角度</span><br><span class="line">explode=(0.1,0,0,0,0,0,0,0,0,0)代表将第一个扇区拉出来0.1，作为突出显示</span><br><span class="line">autopct=&apos;%1.1f%%&apos;,代表给出每个扇区的占比 ，精确到小数点后1位</span><br><span class="line"></span><br><span class="line">plt.pie(top10.Sales,labels=top10.Company,</span><br><span class="line">        colors=[&apos;r&apos;,&apos;y&apos;,&apos;b&apos;,&apos;g&apos;,&apos;c&apos;,&apos;r&apos;,&apos;y&apos;,&apos;b&apos;,&apos;g&apos;,&apos;c&apos;],</span><br><span class="line">        startangle=90,</span><br><span class="line">        explode=(0.1,0,0,0,0,0,0,0,0,0),</span><br><span class="line">        autopct=&apos;%1.1f%%&apos;)</span><br><span class="line">plt.axis(&apos;equal&apos;)</span><br></pre></td></tr></table></figure></p><p>输出如下</p><p><img src="https://upload-images.jianshu.io/upload_images/4263204-72bf0ac1a29f00f8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><h5 id="散点图"><a href="#散点图" class="headerlink" title="散点图"></a>散点图</h5><p>top10公司中，各公司销售额与订单数的关系，展示各公司交易习惯-偏好大订单还是小额订单。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">plt.style.use(&apos;ggplot&apos;)</span><br><span class="line">#scatter绘制散点图，s设置点大小</span><br><span class="line">plt.scatter(x=top10.Purchases,y=top10.Sales,s=100)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p>输出如下</p><p><img src="https://upload-images.jianshu.io/upload_images/4263204-b3e377bbc4010fec.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><h5 id="直方图"><a href="#直方图" class="headerlink" title="直方图"></a>直方图</h5><p>对于原始数据df中，每笔订单的交易额(ext price)，统计单笔订单交易额分布情况。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#hist绘制直方图，bins设置区间个数</span><br><span class="line">plt.hist(df[&apos;ext price&apos;],bins=20,rwidth=0.8)</span><br></pre></td></tr></table></figure><p>输出如下</p><p><img src="https://upload-images.jianshu.io/upload_images/4263204-94c99a579a43eded.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>可以看到，单笔订单交易额在200~600美元的订单最多，可以从一方面反映客户的下单偏好-小额订单。</p><p>当然，更有价值的分析应该下沉到各公司的单笔订单金额去分析，这里暂不做展开。</p><h3 id="04-总结"><a href="#04-总结" class="headerlink" title="04 总结"></a>04 总结</h3><p>以上可视化主要利用matplotlib，主要涉及到条形图barh bar，直方图hist，饼图pie，散点图scatter，多图fig.add_subplot。</p><p>作图代码千千万，要收集整理，用以致学。</p><p>希望对你有帮助~</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/4263204-d4464235e1e3f36c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="PYTHON" scheme="http://yoursite.com/categories/PYTHON/"/>
    
    
      <category term="python" scheme="http://yoursite.com/tags/python/"/>
    
  </entry>
  
</feed>
